--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -6,11 +_,16 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import com.google.gson.Gson;
+import com.mohistmc.mohist.MohistConfig;
+import com.mohistmc.mohist.forge.ForgeInjectBukkit;
 import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.logging.LogUtils;
+import com.mojang.serialization.JsonOps;
 import it.unimi.dsi.fastutil.longs.LongIterator;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import java.awt.image.BufferedImage;
@@ -21,6 +_,8 @@
 import java.lang.management.ManagementFactory;
 import java.lang.management.ThreadInfo;
 import java.lang.management.ThreadMXBean;
+import java.math.BigDecimal;
+import java.math.RoundingMode;
 import java.net.Proxy;
 import java.nio.file.Files;
 import java.nio.file.Path;
@@ -34,18 +_,25 @@
 import java.util.Map;
 import java.util.Objects;
 import java.util.Optional;
+import java.util.Queue;
+import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
+import joptsimple.OptionSet;
 import net.minecraft.CrashReport;
 import net.minecraft.ReportedException;
 import net.minecraft.SharedConstants;
@@ -157,7 +_,28 @@
 import net.minecraft.world.level.storage.loot.LootDataManager;
 import net.minecraft.world.phys.Vec2;
 import net.minecraft.world.phys.Vec3;
+import net.minecraftforge.common.ForgeHooks;
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.common.world.ForgeChunkManager;
+import net.minecraftforge.event.ForgeEventFactory;
+import net.minecraftforge.event.level.LevelEvent;
+import net.minecraftforge.fml.util.thread.SidedThreadGroups;
+import net.minecraftforge.gametest.ForgeGameTestHooks;
+import net.minecraftforge.internal.BrandingControl;
+import net.minecraftforge.network.ServerStatusPing;
+import net.minecraftforge.resource.ResourcePackLoader;
+import net.minecraftforge.server.ServerLifecycleHooks;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.craftbukkit.v1_20_R3.CraftServer;
+import org.bukkit.craftbukkit.v1_20_R3.scoreboard.CraftScoreboardManager;
+import org.bukkit.event.server.ServerLoadEvent;
+import org.bukkit.event.world.WorldLoadEvent;
+import org.bukkit.plugin.PluginLoadOrder;
 import org.slf4j.Logger;
+import org.spigotmc.SpigotConfig;
+import org.spigotmc.WatchdogThread;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, CommandSource, AutoCloseable {
    public static final Logger LOGGER = LogUtils.getLogger();
@@ -191,10 +_,10 @@
    };
    private boolean willStartRecordingMetrics;
    @Nullable
-   private MinecraftServer.TimeProfiler debugCommandProfiler;
+   private TimeProfiler debugCommandProfiler;
    private boolean debugCommandProfilerDelayStart;
-   private final ServerConnectionListener connection;
-   private final ChunkProgressListenerFactory progressListenerFactory;
+   private ServerConnectionListener connection;
+   public final ChunkProgressListenerFactory progressListenerFactory;
    @Nullable
    private ServerStatus status;
    @Nullable
@@ -203,8 +_,8 @@
    public final DataFixer fixerUpper;
    private String localIp;
    private int port = -1;
-   private final LayeredRegistryAccess<RegistryLayer> registries;
-   public final Map<ResourceKey<Level>, ServerLevel> levels = Maps.newLinkedHashMap();
+   public final LayeredRegistryAccess<RegistryLayer> registries;
+   public Map<ResourceKey<Level>, ServerLevel> levels = Maps.newLinkedHashMap();
    private PlayerList playerList;
    private volatile boolean running = true;
    private boolean stopped;
@@ -241,25 +_,43 @@
    private final ServerFunctionManager functionManager;
    private boolean enforceWhitelist;
    private float smoothedTickTimeMillis;
-   private final Executor executor;
+   public final Executor executor;
    @Nullable
    private String serverId;
-   public MinecraftServer.ReloadableResources resources;
+   public ReloadableResources resources;
    private final StructureTemplateManager structureTemplateManager;
    private final ServerTickRateManager tickRateManager;
    protected final WorldData worldData;
    private volatile boolean isSaving;
 
+   // CraftBukkit start
+   public static WorldLoader.DataLoadContext worldLoader;
+   public CraftServer server;
+   public static OptionSet options;
+   public ConsoleCommandSender console;
+   public static int currentTick = 0; // Paper - Further improve tick loop
+   public Queue<Runnable> processQueue = new ConcurrentLinkedQueue<Runnable>();
+   public int autosavePeriod;
+   public Commands vanillaCommandDispatcher;
+   private boolean forceTicks;
+   // CraftBukkit end
+   // Spigot start
+   public static final int TPS = 20;
+   public static final int TICK_TIME = 1000000000 / TPS;
+   private static final int SAMPLE_INTERVAL = 20; // Paper
+   public final double[] recentTps = new double[ 4 ]; // Purpur
+   // Spigot end
+
    public static <S extends MinecraftServer> S spin(Function<Thread, S> p_129873_) {
       AtomicReference<S> atomicreference = new AtomicReference<>();
-      Thread thread = new Thread(() -> {
+      Thread thread = new Thread(SidedThreadGroups.SERVER, () -> {
          atomicreference.get().runServer();
       }, "Server thread");
       thread.setUncaughtExceptionHandler((p_177909_, p_177910_) -> {
          LOGGER.error("Uncaught exception in server thread", p_177910_);
       });
       if (Runtime.getRuntime().availableProcessors() > 4) {
-         thread.setPriority(8);
+         thread.setPriority(MohistConfig.yml.getInt("threadpriority.server_thread", 8));
       }
 
       S s = p_129873_.apply(thread);
@@ -272,19 +_,19 @@
       super("Server");
       this.registries = p_236726_.registries();
       this.worldData = p_236726_.worldData();
-      if (!this.registries.compositeAccess().registryOrThrow(Registries.LEVEL_STEM).containsKey(LevelStem.OVERWORLD)) {
+      if (false && !this.registries.compositeAccess().registryOrThrow(Registries.LEVEL_STEM).containsKey(LevelStem.OVERWORLD)) {
          throw new IllegalStateException("Missing Overworld dimension data");
       } else {
          this.proxy = p_236727_;
          this.packRepository = p_236725_;
-         this.resources = new MinecraftServer.ReloadableResources(p_236726_.resourceManager(), p_236726_.dataPackResources());
+         this.resources = new ReloadableResources(p_236726_.resourceManager(), p_236726_.dataPackResources());
          this.services = p_236729_;
          if (p_236729_.profileCache() != null) {
             p_236729_.profileCache().setExecutor(this);
          }
 
-         this.connection = new ServerConnectionListener(this);
-         this.tickRateManager = new ServerTickRateManager(this);
+         // this.connection = new ServerConnectionListener(this); // Spigot
+		 this.tickRateManager = new ServerTickRateManager(this);
          this.progressListenerFactory = p_236730_;
          this.storageSource = p_236724_;
          this.playerDataStorage = p_236724_.createPlayerStorage();
@@ -294,8 +_,11 @@
          this.structureTemplateManager = new StructureTemplateManager(p_236726_.resourceManager(), p_236724_, p_236728_, holdergetter);
          this.serverThread = p_236723_;
          this.executor = Util.backgroundExecutor();
+         // CraftBukkit start
+         this.vanillaCommandDispatcher = p_236726_.dataPackResources().commands;
       }
    }
+
 
    private void readScoreboard(DimensionDataStorage p_129842_) {
       p_129842_.computeIfAbsent(this.getScoreboard().dataFactory(), "scoreboard");
@@ -313,7 +_,6 @@
       ChunkProgressListener chunkprogresslistener = this.progressListenerFactory.create(11);
       this.createLevels(chunkprogresslistener);
       this.forceDifficulty();
-      this.prepareLevels(chunkprogresslistener);
       if (profiledduration != null) {
          profiledduration.finish();
       }
@@ -341,11 +_,14 @@
       List<CustomSpawner> list = ImmutableList.of(new PhantomSpawner(), new PatrolSpawner(), new CatSpawner(), new VillageSiege(), new WanderingTraderSpawner(serverleveldata));
       LevelStem levelstem = registry.get(LevelStem.OVERWORLD);
       ServerLevel serverlevel = new ServerLevel(this, this.executor, this.storageSource, serverleveldata, Level.OVERWORLD, levelstem, p_129816_, flag, j, list, true, (RandomSequences)null);
+      this.initWorld(serverlevel, serverleveldata, worldData, worldoptions); // CraftBukkit
       this.levels.put(Level.OVERWORLD, serverlevel);
       DimensionDataStorage dimensiondatastorage = serverlevel.getDataStorage();
       this.readScoreboard(dimensiondatastorage);
+      this.server.scoreboardManager = new CraftScoreboardManager(this, serverlevel.getScoreboard());
       this.commandStorage = new CommandStorage(dimensiondatastorage);
       WorldBorder worldborder = serverlevel.getWorldBorder();
+      MinecraftForge.EVENT_BUS.post(new LevelEvent.Load(levels.get(Level.OVERWORLD)));
       if (!serverleveldata.isInitialized()) {
          try {
             setInitialSpawn(serverlevel, serverleveldata, worldoptions.generateBonusChest(), flag);
@@ -379,13 +_,43 @@
          if (resourcekey != LevelStem.OVERWORLD) {
             ResourceKey<Level> resourcekey1 = ResourceKey.create(Registries.DIMENSION, resourcekey.location());
             DerivedLevelData derivedleveldata = new DerivedLevelData(this.worldData, serverleveldata);
-            ServerLevel serverlevel1 = new ServerLevel(this, this.executor, this.storageSource, derivedleveldata, resourcekey1, entry.getValue(), p_129816_, flag, j, ImmutableList.of(), false, randomsequences);
+            String name = resourcekey == LevelStem.NETHER ? "DIM1" : "DIM-1";
+            if (resourcekey == LevelStem.NETHER) {
+               if (!this.isNetherEnabled()) {
+                  continue;
+               }
+            } else if (resourcekey == LevelStem.END) {
+               if (!this.server.getAllowEnd()) {
+                  continue;
+               }
+            }
+            Level.craftWorldData(this.server.getGenerator(name), ForgeInjectBukkit.environment.get(resourcekey), this.server.getBiomeProvider(name));
+            // Mohist start - split calculate for ServerLeverl Preparing
+            ChunkProgressListener mohist$progressListener = this.progressListenerFactory.create(11);
+            ServerLevel serverlevel1 = new ServerLevel(this, this.executor, this.storageSource, derivedleveldata, resourcekey1, entry.getValue(), mohist$progressListener, flag, j, ImmutableList.of(), false, randomsequences);
+            this.initWorld(serverlevel1, derivedleveldata, worldData, worldoptions); // CraftBukkit
+            // Mohist end
             worldborder.addListener(new BorderChangeListener.DelegateBorderChangeListener(serverlevel1.getWorldBorder()));
             this.levels.put(resourcekey1, serverlevel1);
+            MinecraftForge.EVENT_BUS.post(new LevelEvent.Load(levels.get(resourcekey)));
          }
       }
 
       worldborder.applySettings(serverleveldata.getWorldBorder());
+
+      for (ServerLevel worldserver : this.getAllLevels()) {
+         mohist$prepareWorld(worldserver);
+      }
+
+      this.server.enablePlugins(PluginLoadOrder.POSTWORLD);
+      this.server.getPluginManager().callEvent(new ServerLoadEvent(ServerLoadEvent.LoadType.STARTUP));
+      this.connection.acceptConnections();
+   }
+
+   private void mohist$prepareWorld(ServerLevel worldserver) {
+      this.prepareLevels(worldserver.getChunkSource().chunkMap.progressListener, worldserver);
+      worldserver.entityManager.tick(); // SPIGOT-6526: Load pending entities so they are available to the API
+      this.server.getPluginManager().callEvent(new WorldLoadEvent(worldserver.getWorld()));
    }
 
    private static void setInitialSpawn(ServerLevel p_177897_, ServerLevelData p_177898_, boolean p_177899_, boolean p_177900_) {
@@ -393,7 +_,23 @@
          p_177898_.setSpawn(BlockPos.ZERO.above(80), 0.0F);
       } else {
          ServerChunkCache serverchunkcache = p_177897_.getChunkSource();
+         if (ForgeEventFactory.onCreateWorldSpawn(p_177897_, p_177898_)) return;
          ChunkPos chunkpos = new ChunkPos(serverchunkcache.randomState().sampler().findSpawnPosition());
+         // CraftBukkit start
+         if (p_177897_.generator != null) {
+            Random rand = new Random(p_177897_.getSeed());
+            Location spawn = p_177897_.generator.getFixedSpawnLocation(p_177897_.getWorld(), rand);
+
+            if (spawn != null) {
+               if (spawn.getWorld() != p_177897_.getWorld()) {
+                  throw new IllegalStateException("Cannot set spawn point for " + p_177898_.getLevelName() + " to be in another world (" + spawn.getWorld().getName() + ")");
+               } else {
+                  p_177898_.setSpawn(new BlockPos(spawn.getBlockX(), spawn.getBlockY(), spawn.getBlockZ()), spawn.getYaw());
+                  return;
+               }
+            }
+         }
+         // CraftBukkit end
          int i = serverchunkcache.getGenerator().getSpawnHeight(p_177897_);
          if (i < p_177897_.getMinBuildHeight()) {
             BlockPos blockpos = chunkpos.getWorldPosition();
@@ -448,40 +_,84 @@
       serverleveldata.setGameType(GameType.SPECTATOR);
    }
 
-   private void prepareLevels(ChunkProgressListener p_129941_) {
-      ServerLevel serverlevel = this.overworld();
+   // CraftBukkit start
+   public void initWorld(ServerLevel serverlevel, ServerLevelData serverleveldata, WorldData saveData,  WorldOptions worldoptions) {
+      boolean flag = saveData.isDebugWorld();
+      // CraftBukkit start
+      if (serverlevel.generator != null) {
+         serverlevel.getWorld().getPopulators().addAll(serverlevel.generator.getDefaultPopulators(serverlevel.getWorld()));
+      }
+      WorldBorder worldborder = serverlevel.getWorldBorder();
+      worldborder.applySettings(serverleveldata.getWorldBorder()); // CraftBukkit - move up so that WorldBorder is set during WorldInitEvent
+
+      if (!serverleveldata.isInitialized()) {
+         try {
+            setInitialSpawn(serverlevel, serverleveldata, worldoptions.generateBonusChest(), flag);
+            serverleveldata.setInitialized(true);
+            if (flag) {
+               this.setupDebugLevel(this.worldData);
+            }
+         } catch (Throwable throwable1) {
+            CrashReport crashreport = CrashReport.forThrowable(throwable1, "Exception initializing level");
+
+            try {
+               serverlevel.fillReportDetails(crashreport);
+            } catch (Throwable throwable) {
+            }
+
+            throw new ReportedException(crashreport);
+         }
+
+         serverleveldata.setInitialized(true);
+      }
+   }
+   // CraftBukkit end
+
+   public AtomicReference<ServerLevel> prepareLevels$serverlevel = new AtomicReference<>(this.overworld());
+
+   public void prepareLevels(ChunkProgressListener pListener, ServerLevel serverlevel) {
+      prepareLevels$serverlevel.set(serverlevel);
+      prepareLevels(pListener);
+   }
+
+   public void prepareLevels(ChunkProgressListener p_129941_) {
+      this.markWorldsDirty();
+      ServerLevel serverlevel = prepareLevels$serverlevel.getAndSet(this.overworld());
+      MinecraftForge.EVENT_BUS.post(new LevelEvent.Load(serverlevel));
+      this.forceTicks = true;
       LOGGER.info("Preparing start region for dimension {}", (Object)serverlevel.dimension().location());
       BlockPos blockpos = serverlevel.getSharedSpawnPos();
       p_129941_.updateSpawnPos(new ChunkPos(blockpos));
       ServerChunkCache serverchunkcache = serverlevel.getChunkSource();
       this.nextTickTimeNanos = Util.getNanos();
-      serverchunkcache.addRegionTicket(TicketType.START, new ChunkPos(blockpos), 11, Unit.INSTANCE);
-
-      while(serverchunkcache.getTickingGenerated() != 441) {
-         this.nextTickTimeNanos = Util.getNanos() + PREPARE_LEVELS_DEFAULT_DELAY_NANOS;
-         this.waitUntilNextTick();
+      if (serverlevel.getWorld().getKeepSpawnInMemory()) {
+         serverchunkcache.addRegionTicket(TicketType.START, new ChunkPos(blockpos), 11, Unit.INSTANCE);
+         while (serverchunkcache.getTickingGenerated() != 441) {
+            this.executeModerately();
+         }
       }
-
-      this.nextTickTimeNanos = Util.getNanos() + PREPARE_LEVELS_DEFAULT_DELAY_NANOS;
-      this.waitUntilNextTick();
-
-      for(ServerLevel serverlevel1 : this.levels.values()) {
-         ForcedChunksSavedData forcedchunkssaveddata = serverlevel1.getDataStorage().get(ForcedChunksSavedData.factory(), "chunks");
+      this.executeModerately();
+      if (true) {
+         ForcedChunksSavedData forcedchunkssaveddata = serverlevel.getDataStorage().get(ForcedChunksSavedData.factory(), "chunks");
          if (forcedchunkssaveddata != null) {
             LongIterator longiterator = forcedchunkssaveddata.getChunks().iterator();
 
-            while(longiterator.hasNext()) {
+            while (longiterator.hasNext()) {
                long i = longiterator.nextLong();
                ChunkPos chunkpos = new ChunkPos(i);
-               serverlevel1.getChunkSource().updateChunkForced(chunkpos, true);
+               serverlevel.getChunkSource().updateChunkForced(chunkpos, true);
             }
+            ForgeChunkManager.reinstatePersistentChunks(serverlevel, forcedchunkssaveddata);
          }
       }
-
-      this.nextTickTimeNanos = Util.getNanos() + PREPARE_LEVELS_DEFAULT_DELAY_NANOS;
-      this.waitUntilNextTick();
+      // CraftBukkit start
+      this.executeModerately();
+      // CraftBukkit end
       p_129941_.stop();
-      this.updateMobSpawningFlags();
+      // CraftBukkit start
+      serverlevel.setSpawnSettings(this.isSpawningMonsters(), this.isSpawningAnimals());
+      this.forceTicks = false;
+      // CraftBukkit end
    }
 
    public GameType getDefaultGameType() {
@@ -515,6 +_,13 @@
       serverleveldata.setWorldBorder(serverlevel2.getWorldBorder().createSettings());
       this.worldData.setCustomBossEvents(this.getCustomBossEvents().save());
       this.storageSource.saveDataTag(this.registryAccess(), this.worldData, this.getPlayerList().getSingleplayerData());
+      for (ServerLevel world : this.getAllLevels()) {
+         if (world.convertable != this.storageSource) {
+            world.K.setWorldBorder(world.getWorldBorder().createSettings());
+            world.K.setCustomBossEvents(this.getCustomBossEvents().save());
+            world.convertable.saveDataTag(this.registryAccess(), world.K, this.getPlayerList().getSingleplayerData());
+         }
+      }
       if (p_129887_) {
          for(ServerLevel serverlevel1 : this.getAllLevels()) {
             LOGGER.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", (Object)serverlevel1.getChunkSource().chunkMap.getStorageName());
@@ -543,18 +_,44 @@
       this.stopServer();
    }
 
+   // CraftBukkit start
+   private boolean hasStopped = false;
+   private final Object stopLock = new Object();
+   public final boolean hasStopped() {
+      synchronized (stopLock) {
+         return hasStopped;
+      }
+   }
+   // CraftBukkit end
+
    public void stopServer() {
+      // CraftBukkit start - prevent double stopping on multiple threads
+      synchronized(stopLock) {
+         if (hasStopped) return;
+         hasStopped = true;
+      }
+      // CraftBukkit end
+
       if (this.metricsRecorder.isRecording()) {
          this.cancelRecordingMetrics();
       }
 
       LOGGER.info("Stopping server");
-      this.getConnection().stop();
+      // CraftBukkit start
+      if (this.server != null) {
+         this.server.disablePlugins();
+      }
+      // CraftBukkit end
+      if (this.getConnection() != null) {
+         this.getConnection().stop();
+      }
+
       this.isSaving = true;
       if (this.playerList != null) {
          LOGGER.info("Saving players");
          this.playerList.saveAll();
          this.playerList.removeAll();
+         try { Thread.sleep(100); } catch (InterruptedException ex) {} // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
       }
 
       LOGGER.info("Saving worlds");
@@ -585,6 +_,7 @@
       for(ServerLevel serverlevel2 : this.getAllLevels()) {
          if (serverlevel2 != null) {
             try {
+               MinecraftForge.EVENT_BUS.post(new LevelEvent.Unload(serverlevel2));
                serverlevel2.close();
             } catch (IOException ioexception1) {
                LOGGER.error("Exception closing the level", (Throwable)ioexception1);
@@ -600,6 +_,12 @@
       } catch (IOException ioexception) {
          LOGGER.error("Failed to unlock level {}", this.storageSource.getLevelId(), ioexception);
       }
+      // Spigot start
+      if (SpigotConfig.saveUserCacheOnStopOnly) {
+         LOGGER.info("Saving usercache.json");
+         this.getProfileCache().save();
+      }
+      // Spigot end
 
    }
 
@@ -627,16 +_,80 @@
 
    }
 
+   // Spigot Start
+   private static double calcTps(double avg, double exp, double tps)
+    {
+       return ( avg * exp ) + ( tps * ( 1 - exp ) );
+    }
+
+   // Paper start - Further improve server tick loop
+   private static final long SEC_IN_NANO = 1000000000;
+   private static final long MAX_CATCHUP_BUFFER = TICK_TIME * TPS * 60L;
+   private long lastTick = 0;
+   private long catchupTime = 0;
+   public final RollingAverage tps5s = new RollingAverage(5); // Purpur
+   public final RollingAverage tps1 = new RollingAverage(60);
+   public final RollingAverage tps5 = new RollingAverage(60 * 5);
+   public final RollingAverage tps15 = new RollingAverage(60 * 15);
+
+   public static class RollingAverage {
+      private final int size;
+      private long time;
+      private BigDecimal total;
+      private int index = 0;
+      private final BigDecimal[] samples;
+      private final long[] times;
+
+      RollingAverage(int size) {
+         this.size = size;
+         this.time = size * SEC_IN_NANO;
+         this.total = dec(TPS).multiply(dec(SEC_IN_NANO)).multiply(dec(size));
+         this.samples = new BigDecimal[size];
+         this.times = new long[size];
+         for (int i = 0; i < size; i++) {
+            this.samples[i] = dec(TPS);
+            this.times[i] = SEC_IN_NANO;
+         }
+      }
+
+      private static BigDecimal dec(long t) {
+         return new BigDecimal(t);
+      }
+      public void add(BigDecimal x, long t) {
+         time -= times[index];
+         total = total.subtract(samples[index].multiply(dec(times[index])));
+         samples[index] = x;
+         times[index] = t;
+         time += t;
+         total = total.add(x.multiply(dec(t)));
+         if (++index == size) {
+            index = 0;
+         }
+      }
+
+      public double getAverage() {
+         return total.divide(dec(time), 30, RoundingMode.HALF_UP).doubleValue();
+      }
+   }
+   private static final BigDecimal TPS_BASE = new BigDecimal(1E9).multiply(new BigDecimal(SAMPLE_INTERVAL));
+   // Paper End
+   // Spigot End
+
    protected void runServer() {
       try {
          if (!this.initServer()) {
             throw new IllegalStateException("Failed to initialize server");
          }
 
+         ServerLifecycleHooks.handleServerStarted(this);
          this.nextTickTimeNanos = Util.getNanos();
          this.statusIcon = this.loadStatusIcon().orElse((ServerStatus.Favicon)null);
          this.status = this.buildServerStatus();
+         resetStatusCache(status);
 
+         // Spigot start
+         Arrays.fill( recentTps, 20 );
+         long tickSection = Util.getNanos(), curTime, tickCount = 1; // Paper
          while(this.running) {
             long i;
             if (!this.isPaused() && this.tickRateManager.isSprinting() && this.tickRateManager.checkShouldSprintThisTick()) {
@@ -648,18 +_,43 @@
                long k = Util.getNanos() - this.nextTickTimeNanos;
                if (k > OVERLOADED_THRESHOLD_NANOS + 20L * i && this.nextTickTimeNanos - this.lastOverloadWarningNanos >= OVERLOADED_WARNING_INTERVAL_NANOS + 100L * i) {
                   long j = k / i;
+                  if (server.getWarnOnOverload()) // CraftBukkit
                   LOGGER.warn("Can't keep up! Is the server overloaded? Running {}ms or {} ticks behind", k / TimeUtil.NANOSECONDS_PER_MILLISECOND, j);
                   this.nextTickTimeNanos += j * i;
                   this.lastOverloadWarningNanos = this.nextTickTimeNanos;
                }
             }
 
+            if ( ++MinecraftServer.currentTick % MinecraftServer.SAMPLE_INTERVAL == 0 )
+            {
+               // Paper start
+               curTime = Util.getNanos();
+               final long diff = curTime - tickSection;
+               BigDecimal currentTps = TPS_BASE.divide(new BigDecimal(diff), 30, RoundingMode.HALF_UP);
+               tps5s.add(currentTps, diff); // Purpur
+               tps1.add(currentTps, diff);
+               tps5.add(currentTps, diff);
+               tps15.add(currentTps, diff);
+               // Backwards compat with bad plugins
+               // Purpur start
+               this.recentTps[0] = tps5s.getAverage();
+               this.recentTps[1] = tps1.getAverage();
+               this.recentTps[2] = tps5.getAverage();
+               this.recentTps[3] = tps15.getAverage();
+               // Purpur end
+               // Paper end
+               tickSection = curTime;
+            } else curTime = Util.getNanos(); // Paper
+            // Spigot end
+
             boolean flag = i == 0L;
             if (this.debugCommandProfilerDelayStart) {
                this.debugCommandProfilerDelayStart = false;
                this.debugCommandProfiler = new MinecraftServer.TimeProfiler(Util.getNanos(), this.tickCount);
             }
 
+            // MinecraftServer.currentTick = (int) (System.currentTimeMillis() / 50); // CraftBukkit // Paper - don't overwrite current tick time
+            lastTick = curTime; // Paper
             this.nextTickTimeNanos += i;
             this.startMetricsRecordingTick();
             this.profiler.push("tick");
@@ -679,8 +_,16 @@
             this.isReady = true;
             JvmProfiler.INSTANCE.onServerTick(this.smoothedTickTimeMillis);
          }
+         ServerLifecycleHooks.handleServerStopping(this);
+         ServerLifecycleHooks.expectServerStopped(); // Forge: Has to come before MinecraftServer#onServerCrash to avoid race conditions
       } catch (Throwable throwable1) {
          LOGGER.error("Encountered an unexpected exception", throwable1);
+         // Spigot Start
+         if ( throwable1.getCause() != null )
+         {
+            MinecraftServer.LOGGER.error( "\tCause of unexpected exception was", throwable1.getCause() );
+         }
+         // Spigot End
          CrashReport crashreport = constructOrExtractCrashReport(throwable1);
          this.fillSystemReport(crashreport.getSystemReport());
          File file1 = new File(new File(this.getServerDirectory(), "crash-reports"), "crash-" + Util.getFilenameFormattedDateTime() + "-server.txt");
@@ -690,6 +_,7 @@
             LOGGER.error("We were unable to save this crash report to disk.");
          }
 
+         ServerLifecycleHooks.expectServerStopped(); // Forge: Has to come before MinecraftServer#onServerCrash to avoid race conditions
          this.onServerCrash(crashreport);
       } finally {
          try {
@@ -702,6 +_,8 @@
                this.services.profileCache().clearExecutor();
             }
 
+            ServerLifecycleHooks.handleServerStopped(this);
+            WatchdogThread.doStop(); // Spigot
             this.onServerExit();
          }
 
@@ -732,8 +_,17 @@
    }
 
    private boolean haveTime() {
-      return this.runningTask() || Util.getNanos() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTimeNanos : this.nextTickTimeNanos);
-   }
+      return this.forceTicks || this.runningTask() || Util.getNanos() < (this.mayHaveDelayedTasks ? this.delayedTasksMaxNextTickTimeNanos : this.nextTickTimeNanos);
+   }
+
+   private void executeModerately() {
+      this.runAllTasks();
+      while (!processQueue.isEmpty()) {
+         processQueue.remove().run();
+      }
+      LockSupport.parkNanos("executing tasks", 1000L);
+   }
+   // CraftBukkit end
 
    protected void waitUntilNextTick() {
       this.runAllTasks();
@@ -742,7 +_,7 @@
       });
    }
 
-   protected TickTask wrapRunnable(Runnable p_129852_) {
+   public TickTask wrapRunnable(Runnable p_129852_) {
       return new TickTask(this.tickCount, p_129852_);
    }
 
@@ -797,6 +_,7 @@
             LOGGER.error("Couldn't load server icon", (Throwable)exception);
             return Optional.empty();
          }
+
       });
    }
 
@@ -820,12 +_,14 @@
 
    public void tickServer(BooleanSupplier p_129871_) {
       long i = Util.getNanos();
+      ForgeEventFactory.onPreServerTick(p_129871_, this);
       ++this.tickCount;
       this.tickRateManager.tick();
       this.tickChildren(p_129871_);
       if (i - this.lastServerStatus >= STATUS_EXPIRE_TIME_NANOS) {
          this.lastServerStatus = i;
          this.status = this.buildServerStatus();
+         resetStatusCache(status);
       }
 
       --this.ticksUntilAutosave;
@@ -848,6 +_,18 @@
       long l = Util.getNanos();
       this.logTickTime(l - i);
       this.profiler.pop();
+      WatchdogThread.tick(); // Spigot
+      ForgeEventFactory.onPostServerTick(p_129871_, this);
+   }
+
+   private static final Gson GSON = new Gson();
+   private String cachedServerStatus; // FORGE: cache the server status json in case a client spams requests
+   private void resetStatusCache(ServerStatus status) {
+      this.cachedServerStatus = GSON.toJson(ServerStatus.CODEC.encodeStart(JsonOps.INSTANCE, status)
+              .result().orElseThrow());
+   }
+   public String getStatusJson() {
+      return cachedServerStatus;
    }
 
    private int computeNextAutosaveInterval() {
@@ -876,7 +_,7 @@
 
    private ServerStatus buildServerStatus() {
       ServerStatus.Players serverstatus$players = this.buildPlayerStatus();
-      return new ServerStatus(Component.nullToEmpty(this.motd), Optional.of(serverstatus$players), Optional.of(ServerStatus.Version.current()), Optional.ofNullable(this.statusIcon), this.enforceSecureProfile());
+      return new ServerStatus(Component.nullToEmpty(this.motd), Optional.of(serverstatus$players), Optional.of(ServerStatus.Version.current()), Optional.ofNullable(this.statusIcon), this.enforceSecureProfile(), Optional.of(new ServerStatusPing()));
    }
 
    private ServerStatus.Players buildPlayerStatus() {
@@ -900,24 +_,27 @@
    }
 
    public void tickChildren(BooleanSupplier p_129954_) {
-      this.getPlayerList().getPlayers().forEach((p_296434_) -> {
-         p_296434_.connection.suspendFlushing();
-      });
+      this.server.getScheduler().mainThreadHeartbeat(this.tickCount); // CraftBukkit
       this.profiler.push("commandFunctions");
       this.getFunctions().tick();
       this.profiler.popPush("levels");
 
-      for(ServerLevel serverlevel : this.getAllLevels()) {
+      // Send time updates to everyone, it will get the right time from the world the player is in.
+      if (this.tickCount % 20 == 0) {
+         for (int i = 0; i < this.getPlayerList().players.size(); ++i) {
+            ServerPlayer entityplayer = (ServerPlayer) this.getPlayerList().players.get(i);
+            entityplayer.connection.send(new ClientboundSetTimePacket(entityplayer.level.getGameTime(), entityplayer.getPlayerTime(), entityplayer.level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT))); // Add support for per player time
+         }
+      }
+
+      for(ServerLevel serverlevel : this.getWorldArray()) {
+         long tickStart = Util.getNanos();
          this.profiler.push(() -> {
             return serverlevel + " " + serverlevel.dimension().location();
          });
-         if (this.tickCount % 20 == 0) {
-            this.profiler.push("timeSync");
-            this.synchronizeTime(serverlevel);
-            this.profiler.pop();
-         }
 
          this.profiler.push("tick");
+         ForgeEventFactory.onPreLevelTick(serverlevel, p_129954_);
 
          try {
             serverlevel.tick(p_129954_);
@@ -926,16 +_,18 @@
             serverlevel.fillReportDetails(crashreport);
             throw new ReportedException(crashreport);
          }
+         ForgeEventFactory.onPostLevelTick(serverlevel, p_129954_);
 
          this.profiler.pop();
          this.profiler.pop();
+         perWorldTickTimes.computeIfAbsent(serverlevel.dimension(), k -> new long[100])[this.tickCount % 100] = Util.getNanos() - tickStart;
       }
 
       this.profiler.popPush("connection");
       this.getConnection().tick();
       this.profiler.popPush("players");
       this.playerList.tick();
-      if (SharedConstants.IS_RUNNING_IN_IDE && this.tickRateManager.runsNormally()) {
+      if (ForgeGameTestHooks.isGametestEnabled()) {
          GameTestTicker.SINGLETON.tick();
       }
 
@@ -998,6 +_,16 @@
       return this.levels.get(p_129881_);
    }
 
+   // CraftBukkit start
+   public void addLevel(ServerLevel level) {
+      this.levels.put(level.dimension(), level); // Mohist
+   }
+
+   public void removeLevel(ServerLevel level) {
+      this.levels.remove(level.dimension()); // Mohist
+   }
+    // CraftBukkit end
+
    public Set<ResourceKey<Level>> levelKeys() {
       return this.levels.keySet();
    }
@@ -1024,7 +_,7 @@
 
    @DontObfuscate
    public String getServerModName() {
-      return "vanilla";
+      return BrandingControl.getServerBranding();
    }
 
    public SystemReport fillSystemReport(SystemReport p_177936_) {
@@ -1143,12 +_,12 @@
       this.isDemo = p_129976_;
    }
 
-   public Optional<MinecraftServer.ServerResourcePackInfo> getServerResourcePack() {
+   public Optional<ServerResourcePackInfo> getServerResourcePack() {
       return Optional.empty();
    }
 
    public boolean isResourcePackRequired() {
-      return this.getServerResourcePack().filter(MinecraftServer.ServerResourcePackInfo::isRequired).isPresent();
+      return this.getServerResourcePack().filter(ServerResourcePackInfo::isRequired).isPresent();
    }
 
    public abstract boolean isDedicatedServer();
@@ -1200,7 +_,7 @@
    public abstract boolean isCommandBlockEnabled();
 
    public String getMotd() {
-      return this.motd;
+      return MohistConfig.motdFirstLine + "\n" + MohistConfig.motdSecondLine;
    }
 
    public void setMotd(String p_129990_) {
@@ -1226,7 +_,7 @@
    }
 
    public ServerConnectionListener getConnection() {
-      return this.connection;
+      return this.connection == null ? this.connection = new ServerConnectionListener(this) : this.connection; // Spigot
    }
 
    public boolean isReady() {
@@ -1360,11 +_,12 @@
             }
 
          }).thenApply((p_212904_) -> {
-            return new MinecraftServer.ReloadableResources(closeableresourcemanager, p_212904_);
+            return new ReloadableResources(closeableresourcemanager, p_212904_);
          });
       }).thenAcceptAsync((p_248090_) -> {
          this.resources.close();
          this.resources = p_248090_;
+         this.server.syncCommands(); // SPIGOT-5884: Lost on reload
          this.packRepository.setSelected(p_129862_);
          WorldDataConfiguration worlddataconfiguration = new WorldDataConfiguration(getSelectedPacks(this.packRepository), this.worldData.enabledFeatures());
          this.worldData.setDataConfiguration(worlddataconfiguration);
@@ -1373,6 +_,7 @@
          this.getPlayerList().reloadResources();
          this.functionManager.replaceLibrary(this.resources.managers.getFunctionLibrary());
          this.structureTemplateManager.onResourceManagerReload(this.resources.resourceManager);
+         this.getPlayerList().getPlayers().forEach(this.getPlayerList()::sendPlayerPermissionLevel); //Forge: Fix newly added/modified commands not being sent to the client when commands reload.
       }, this);
       if (this.isSameThread()) {
          this.managedBlock(completablefuture::isDone);
@@ -1382,10 +_,13 @@
    }
 
    public static WorldDataConfiguration configurePackRepository(PackRepository p_248681_, DataPackConfig p_248920_, boolean p_249869_, FeatureFlagSet p_251243_) {
+      ResourcePackLoader.loadResourcePacks(p_248681_, false);
       p_248681_.reload();
+      DataPackConfig.DEFAULT.addModPacks(ForgeHooks.getModPacks());
+      p_248920_.addModPacks(ForgeHooks.getModPacks());
       if (p_249869_) {
-         p_248681_.setSelected(Collections.singleton("vanilla"));
-         return WorldDataConfiguration.DEFAULT;
+         p_248681_.setSelected(ForgeHooks.getModPacksWithVanilla());
+         return new WorldDataConfiguration(new DataPackConfig(ForgeHooks.getModPacksWithVanilla(), ImmutableList.of()), FeatureFlags.DEFAULT_FLAGS);
       } else {
          Set<String> set = Sets.newLinkedHashSet();
 
@@ -1551,6 +_,31 @@
 
    public abstract boolean isSingleplayerOwner(GameProfile p_129840_);
 
+   private Map<ResourceKey<Level>, long[]> perWorldTickTimes = Maps.newIdentityHashMap();
+   @Nullable
+   public long[] getTickTime(ResourceKey<Level> dim) {
+      return perWorldTickTimes.get(dim);
+   }
+
+   @Deprecated //Forge Internal use Only, You can screw up a lot of things if you mess with this map.
+   public synchronized Map<ResourceKey<Level>, ServerLevel> forgeGetWorldMap() {
+      return this.levels;
+   }
+   private int worldArrayMarker = 0;
+   private int worldArrayLast = -1;
+   private ServerLevel[] worldArray;
+   @Deprecated //Forge Internal use Only, use to protect against concurrent modifications in the world tick loop.
+   public synchronized void markWorldsDirty() {
+      worldArrayMarker++;
+   }
+   private ServerLevel[] getWorldArray() {
+      if (worldArrayMarker == worldArrayLast && worldArray != null)
+         return worldArray;
+      worldArray = this.levels.values().stream().toArray(x -> new ServerLevel[x]);
+      worldArrayLast = worldArrayMarker;
+      return worldArray;
+   }
+
    public void dumpServerProperties(Path p_177911_) throws IOException {
    }
 
@@ -1716,6 +_,10 @@
       return this.worldData;
    }
 
+   public ReloadableResources getServerResources() {
+       return resources;
+   }
+
    public RegistryAccess.Frozen registryAccess() {
       return this.registries.compositeAccess();
    }
@@ -1777,6 +_,11 @@
 
    }
 
+   // CraftBukkit start
+   public final ExecutorService chatExecutor = Executors.newCachedThreadPool(
+           new ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").build());
+   // CraftBukkit end
+
    public ChatDecorator getChatDecorator() {
       return ChatDecorator.PLAIN;
    }
@@ -1835,4 +_,18 @@
          };
       }
    }
+
+   public static MinecraftServer getServer() {
+      return ( Bukkit.getServer() instanceof CraftServer) ? ((CraftServer) Bukkit.getServer()).getServer() : null;
+   }
+
+   @Override
+   public boolean isSameThread() {
+      return super.isSameThread() || this.isStopped(); // CraftBukkit - MC-142590
+   }
+
+   public boolean isDebugging() {
+      return false;
+   }
+   // CraftBukkit end
 }

--- a/net/minecraft/server/level/ChunkHolder.java
+++ b/net/minecraft/server/level/ChunkHolder.java
@@ -1,11 +_,13 @@
 package net.minecraft.server.level;
 
+import com.mojang.datafixers.util.Either;
 import com.mojang.datafixers.util.Pair;
 import it.unimi.dsi.fastutil.shorts.ShortOpenHashSet;
 import it.unimi.dsi.fastutil.shorts.ShortSet;
 import java.util.ArrayList;
 import java.util.BitSet;
 import java.util.List;
+import java.util.Optional;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.Executor;
@@ -21,6 +_,7 @@
 import net.minecraft.network.protocol.game.ClientboundLightUpdatePacket;
 import net.minecraft.network.protocol.game.ClientboundSectionBlocksUpdatePacket;
 import net.minecraft.util.DebugBuffer;
+import net.minecraft.util.Mth;
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelHeightAccessor;
@@ -40,7 +_,7 @@
     public static final CompletableFuture<ChunkResult<ChunkAccess>> UNLOADED_CHUNK_FUTURE = CompletableFuture.completedFuture(UNLOADED_CHUNK);
     public static final ChunkResult<LevelChunk> UNLOADED_LEVEL_CHUNK = ChunkResult.error("Unloaded level chunk");
     public static final ChunkResult<ChunkAccess> NOT_DONE_YET = ChunkResult.error("Not done yet");
-    public static final CompletableFuture<ChunkResult<LevelChunk>> UNLOADED_LEVEL_CHUNK_FUTURE = CompletableFuture.completedFuture(UNLOADED_LEVEL_CHUNK);
+    private static final CompletableFuture<ChunkResult<LevelChunk>> UNLOADED_LEVEL_CHUNK_FUTURE = CompletableFuture.completedFuture(UNLOADED_LEVEL_CHUNK);
     private static final List<ChunkStatus> CHUNK_STATUSES = ChunkStatus.getStatusList();
     private final AtomicReferenceArray<CompletableFuture<ChunkResult<ChunkAccess>>> futures = new AtomicReferenceArray<>(CHUNK_STATUSES.size());
     private final LevelHeightAccessor levelHeightAccessor;
@@ -50,7 +_,7 @@
     private CompletableFuture<ChunkAccess> chunkToSave = CompletableFuture.completedFuture(null);
     @Nullable
     private final DebugBuffer<ChunkHolder.ChunkSaveDebug> chunkToSaveHistory = null;
-    public int oldTicketLevel;
+    private int oldTicketLevel;
     private int ticketLevel;
     private int queueLevel;
     private final ChunkPos pos;
@@ -60,10 +_,11 @@
     private final BitSet skyChangedLightSectionFilter = new BitSet();
     private final LevelLightEngine lightEngine;
     private final ChunkHolder.LevelChangeListener onLevelChange;
-    public final ChunkHolder.PlayerProvider playerProvider;
+    private final ChunkHolder.PlayerProvider playerProvider;
     private boolean wasAccessibleSinceLastSave;
     private CompletableFuture<Void> pendingFullStateConfirmation = CompletableFuture.completedFuture(null);
     private CompletableFuture<?> sendSync = CompletableFuture.completedFuture(null);
+    LevelChunk currentlyLoading; // Forge: Used to bypass future chain when loading chunks.
 
     public ChunkHolder(
         ChunkPos p_142986_,
@@ -85,6 +_,20 @@
         this.changedBlocksPerSection = new ShortSet[p_142988_.getSectionsCount()];
     }
 
+    // CraftBukkit start
+    public LevelChunk getFullChunkNow() {
+        // Note: We use the oldTicketLevel for isLoaded checks.
+        if (!ChunkLevel.fullStatus(this.oldTicketLevel).isOrAfter(FullChunkStatus.FULL)) return null;
+        return this.getFullChunkNowUnchecked();
+    }
+
+    public LevelChunk getFullChunkNowUnchecked() {
+        CompletableFuture<ChunkResult<ChunkAccess>> statusFuture = this.getFutureIfPresentUnchecked(ChunkStatus.FULL);
+        ChunkResult<ChunkAccess> either = statusFuture.getNow(null);
+        return (either == null) ? null : (LevelChunk) either.orElse(null);
+    }
+    // CraftBukkit end
+
     public CompletableFuture<ChunkResult<ChunkAccess>> getFutureIfPresentUnchecked(ChunkStatus p_331856_) {
         CompletableFuture<ChunkResult<ChunkAccess>> completablefuture = this.futures.get(p_331856_.getIndex());
         return completablefuture == null ? UNLOADED_CHUNK_FUTURE : completablefuture;
@@ -348,6 +_,29 @@
         boolean flag1 = ChunkLevel.isLoaded(this.ticketLevel);
         FullChunkStatus fullchunkstatus = ChunkLevel.fullStatus(this.oldTicketLevel);
         FullChunkStatus fullchunkstatus1 = ChunkLevel.fullStatus(this.ticketLevel);
+        // CraftBukkit start
+        // ChunkUnloadEvent: Called before the chunk is unloaded: isChunkLoaded is still true and chunk can still be modified by plugins.
+        if (fullchunkstatus.isOrAfter(FullChunkStatus.FULL) && !fullchunkstatus1.isOrAfter(FullChunkStatus.FULL)) {
+            this.getFutureIfPresentUnchecked(ChunkStatus.FULL).thenAccept((either) -> {
+                LevelChunk chunk = (LevelChunk) either.orElse(null);
+                if (chunk != null) {
+                    p_143004_.callbackExecutor.execute(() -> {
+                        // Minecraft will apply the chunks tick lists to the world once the chunk got loaded, and then store the tick
+                        // lists again inside the chunk once the chunk becomes inaccessible and set the chunk's needsSaving flag.
+                        // These actions may however happen deferred, so we manually set the needsSaving flag already here.
+                        chunk.setUnsaved(true);
+                        chunk.unloadCallback();
+                    });
+                }
+            }).exceptionally((throwable) -> {
+                // ensure exceptions are printed, by default this is not the case
+                return null;
+            });
+
+            // Run callback right away if the future was already done
+            p_143004_.callbackExecutor.run();
+        }
+        // CraftBukkit end
         if (flag) {
             ChunkResult<ChunkAccess> chunkresult = ChunkResult.error(() -> "Unloaded ticket level " + this.pos);
 
@@ -409,7 +_,26 @@
 
         this.onLevelChange.onLevelChange(this.pos, this::getQueueLevel, this.ticketLevel, this::setQueueLevel);
         this.oldTicketLevel = this.ticketLevel;
-    }
+        // CraftBukkit start
+        // ChunkLoadEvent: Called after the chunk is loaded: isChunkLoaded returns true and chunk is ready to be modified by plugins.
+        if (!fullchunkstatus.isOrAfter(FullChunkStatus.FULL) && fullchunkstatus1.isOrAfter(FullChunkStatus.FULL)) {
+            this.getFutureIfPresentUnchecked(ChunkStatus.FULL).thenAccept((either) -> {
+                LevelChunk chunk = (LevelChunk) either.orElse(null);
+                if (chunk != null) {
+                    p_143004_.callbackExecutor.execute(() -> {
+                        chunk.loadCallback();
+                    });
+                }
+            }).exceptionally((throwable) -> {
+                // ensure exceptions are printed, by default this is not the case
+                return null;
+            });
+
+            // Run callback right away if the future was already done
+            p_143004_.callbackExecutor.run();
+        }
+      // CraftBukkit end
+   }
 
     public boolean wasAccessibleSinceLastSave() {
         return this.wasAccessibleSinceLastSave;

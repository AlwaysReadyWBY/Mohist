--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -6,6 +_,7 @@
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.google.common.collect.ImmutableList.Builder;
+import com.google.common.util.concurrent.AtomicDouble;
 import com.google.gson.JsonElement;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
@@ -40,6 +_,7 @@
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
 import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
@@ -98,6 +_,7 @@
 import net.minecraft.world.level.storage.LevelStorageSource;
 import net.minecraft.world.phys.Vec3;
 import org.apache.commons.lang3.mutable.MutableBoolean;
+import org.bukkit.craftbukkit.generator.CustomChunkGenerator;
 import org.slf4j.Logger;
 
 public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider {
@@ -111,35 +_,56 @@
     public static final int MIN_VIEW_DISTANCE = 2;
     public static final int MAX_VIEW_DISTANCE = 32;
     public static final int FORCED_TICKET_LEVEL = ChunkLevel.byStatus(FullChunkStatus.ENTITY_TICKING);
-    public final Long2ObjectLinkedOpenHashMap<ChunkHolder> updatingChunkMap = new Long2ObjectLinkedOpenHashMap<>();
+    private final Long2ObjectLinkedOpenHashMap<ChunkHolder> updatingChunkMap = new Long2ObjectLinkedOpenHashMap<>();
     public volatile Long2ObjectLinkedOpenHashMap<ChunkHolder> visibleChunkMap = this.updatingChunkMap.clone();
     private final Long2ObjectLinkedOpenHashMap<ChunkHolder> pendingUnloads = new Long2ObjectLinkedOpenHashMap<>();
     private final LongSet entitiesInLevel = new LongOpenHashSet();
-    public final ServerLevel level;
+    final ServerLevel level;
     private final ThreadedLevelLightEngine lightEngine;
     private final BlockableEventLoop<Runnable> mainThreadExecutor;
-    public ChunkGenerator generator;
+    private ChunkGenerator generator;
     private final RandomState randomState;
     private final ChunkGeneratorStructureState chunkGeneratorState;
     private final Supplier<DimensionDataStorage> overworldDataStorage;
     private final PoiManager poiManager;
-    public final LongSet toDrop = new LongOpenHashSet();
+   	public final LongSet toDrop = new LongOpenHashSet();
     private boolean modified;
     private final ChunkTaskPriorityQueueSorter queueSorter;
     private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> worldgenMailbox;
     private final ProcessorHandle<ChunkTaskPriorityQueueSorter.Message<Runnable>> mainThreadMailbox;
-    public final ChunkProgressListener progressListener;
-    private final ChunkStatusUpdateListener chunkStatusListener;
-    public final ChunkMap.DistanceManager distanceManager;
+   	public final ChunkProgressListener progressListener;
+   	private final ChunkStatusUpdateListener chunkStatusListener;
+   	public final ChunkMap.DistanceManager distanceManager;
     private final AtomicInteger tickingGenerated = new AtomicInteger();
     private final String storageName;
     private final PlayerMap playerMap = new PlayerMap();
-    public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap = new Int2ObjectOpenHashMap<>();
+   	public final Int2ObjectMap<ChunkMap.TrackedEntity> entityMap = new Int2ObjectOpenHashMap<>();
     private final Long2ByteMap chunkTypeCache = new Long2ByteOpenHashMap();
     private final Long2LongMap chunkSaveCooldowns = new Long2LongOpenHashMap();
     private final Queue<Runnable> unloadQueue = Queues.newConcurrentLinkedQueue();
-    private int serverViewDistance;
-    private WorldGenContext worldGenContext;
+   	public int serverViewDistance;
+	private WorldGenContext worldGenContext;
+
+    // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
+    public final CallbackExecutor callbackExecutor = new CallbackExecutor();
+    public static final class CallbackExecutor implements java.util.concurrent.Executor, Runnable {
+
+        private final java.util.Queue<Runnable> queue = new java.util.ArrayDeque<>();
+
+        @Override
+        public void execute(Runnable runnable) {
+            queue.add(runnable);
+        }
+
+        @Override
+        public void run() {
+            Runnable task;
+            while ((task = queue.poll()) != null) {
+                task.run();
+            }
+        }
+    };
+    // CraftBukkit end
 
     public ChunkMap(
         ServerLevel p_214836_,
@@ -166,9 +_,16 @@
         this.storageName = path.getFileName().toString();
         this.level = p_214836_;
         this.generator = p_214843_;
+
         RegistryAccess registryaccess = p_214836_.registryAccess();
         long i = p_214836_.getSeed();
-        if (p_214843_ instanceof NoiseBasedChunkGenerator noisebasedchunkgenerator) {
+        // CraftBukkit start - SPIGOT-7051: It's a rigged game! Use delegate for random state creation, otherwise it is not so random.
+        ChunkGenerator randomGenerator = p_214843_;
+        if (p_214843_ instanceof CustomChunkGenerator customChunkGenerator) {
+            randomGenerator = customChunkGenerator.getDelegate();
+        }
+        // CraftBukkit end
+        if (randomGenerator instanceof NoiseBasedChunkGenerator noisebasedchunkgenerator) {
             this.randomState = RandomState.create(noisebasedchunkgenerator.generatorSettings().value(), registryaccess.lookupOrThrow(Registries.NOISE), i);
         } else {
             this.randomState = RandomState.create(NoiseGeneratorSettings.dummy(), registryaccess.lookupOrThrow(Registries.NOISE), i);
@@ -413,6 +_,7 @@
                 this.modified = true;
             }
 
+            net.minecraftforge.event.ForgeEventFactory.fireChunkTicketLevelUpdated(this.level, p_140177_, p_140180_, p_140178_, p_140179_);
             return p_140179_;
         }
     }
@@ -521,6 +_,7 @@
                 if (this.pendingUnloads.remove(p_140182_, p_140183_) && p_203002_ != null) {
                     if (p_203002_ instanceof LevelChunk) {
                         ((LevelChunk)p_203002_).setLoaded(false);
+                        net.minecraftforge.event.ForgeEventFactory.onChunkUnload(p_203002_);
                     }
 
                     this.save(p_203002_);
@@ -697,8 +_,23 @@
 
     private static void postLoadProtoChunk(ServerLevel p_143065_, List<CompoundTag> p_143066_) {
         if (!p_143066_.isEmpty()) {
-            p_143065_.addWorldGenChunkEntities(EntityType.loadEntitiesRecursive(p_143066_, p_143065_));
+            // CraftBukkit start - these are spawned serialized (DefinedStructure) and we don't call an add event below at the moment due to ordering complexities
+            p_143065_.addWorldGenChunkEntities(EntityType.loadEntitiesRecursive(p_143066_, p_143065_).filter((entity) -> {
+                boolean needsRemoval = false;
+                net.minecraft.server.dedicated.DedicatedServer server = p_143065_.getCraftServer().getServer();
+                if (!server.areNpcsEnabled() && entity instanceof net.minecraft.world.entity.npc.Npc) {
+                    entity.discard();
+                    needsRemoval = true;
+                }
+                if (!server.isSpawningAnimals() && (entity instanceof net.minecraft.world.entity.animal.Animal || entity instanceof net.minecraft.world.entity.animal.WaterAnimal)) {
+                    entity.discard();
+                    needsRemoval = true;
+                }
+                return !needsRemoval;
+            }));
+            // CraftBukkit end
         }
+
     }
 
     private CompletableFuture<ChunkAccess> protoChunkToFullChunk(ChunkHolder p_140384_, ChunkAccess p_328123_) {
@@ -717,8 +_,14 @@
             levelchunk.runPostLoad();
             if (this.entitiesInLevel.add(chunkpos.toLong())) {
                 levelchunk.setLoaded(true);
+                try {
+                    p_140384_.currentlyLoading = levelchunk; // Forge - bypass the future chain when getChunk is called, this prevents deadlocks.
                 levelchunk.registerAllBlockEntitiesAfterLevelLoad();
                 levelchunk.registerTickContainerInLevel(this.level);
+                    net.minecraftforge.event.ForgeEventFactory.onChunkLoad(levelchunk, !(protochunk instanceof ImposterProtoChunk));
+                } finally {
+                    p_140384_.currentlyLoading = null; // Forge - Stop bypassing the future chain.
+                }
             }
 
             return levelchunk;
@@ -818,6 +_,7 @@
 
                 this.level.getProfiler().incrementCounter("chunkSave");
                 CompoundTag compoundtag = ChunkSerializer.write(this.level, p_140259_);
+                net.minecraftforge.event.ForgeEventFactory.onChunkDataSave(p_140259_, p_140259_.getWorldForge() != null ? p_140259_.getWorldForge() : this.level, compoundtag);
                 this.write(chunkpos, compoundtag).exceptionallyAsync(p_326408_ -> {
                     this.level.getServer().reportChunkSaveFailure(chunkpos);
                     return null;
@@ -977,11 +_,26 @@
         return this.upgradeChunkTag(this.level.dimension(), this.overworldDataStorage, p_214948_, this.generator.getTypeNameForDataFixer());
     }
 
+    // Mohist start - fix mixin
+    AtomicBoolean reducedRange0 = new AtomicBoolean(false);
+    public boolean anyPlayerCloseEnoughForSpawning(ChunkPos pChunkPos, boolean reducedRange) {
+        reducedRange0.set(reducedRange);
+        return anyPlayerCloseEnoughForSpawning(pChunkPos);
+    }
+
     boolean anyPlayerCloseEnoughForSpawning(ChunkPos p_183880_) {
+        int chunkRange = level.spigotConfig.mobSpawnRange;
+        chunkRange = (chunkRange > level.spigotConfig.viewDistance) ? (byte) level.spigotConfig.viewDistance : chunkRange;
+        chunkRange = Math.min(chunkRange, 8);
+
+        double blockRange = (reducedRange0.getAndSet(false)) ? Math.pow(chunkRange << 4, 2) : 16384.0D;
+        // Spigot end
+        // Mohist end
         if (!this.distanceManager.hasPlayersNearby(p_183880_.toLong())) {
             return false;
         } else {
             for (ServerPlayer serverplayer : this.playerMap.getAllPlayers()) {
+                this.mobSpawnRange.set(blockRange);
                 if (this.playerIsCloseEnoughForSpawning(serverplayer, p_183880_)) {
                     return true;
                 }
@@ -1008,14 +_,22 @@
         }
     }
 
+    // Mohist start - fix mixin
+    public AtomicDouble mobSpawnRange = new AtomicDouble(16384.0D);
     private boolean playerIsCloseEnoughForSpawning(ServerPlayer p_183752_, ChunkPos p_183753_) {
         if (p_183752_.isSpectator()) {
             return false;
         } else {
             double d0 = euclideanDistanceSquared(p_183753_, p_183752_);
-            return d0 < 16384.0;
+            return d0 < mobSpawnRange.getAndSet(16384.0D);
         }
     }
+
+    private boolean playerIsCloseEnoughForSpawning(ServerPlayer pPlayer, ChunkPos pChunkPos, double range) { // Spigot
+        mobSpawnRange.set(range);
+        return playerIsCloseEnoughForSpawning(pPlayer, pChunkPos);
+    }
+    // Mohist end
 
     private boolean skipPlayer(ServerPlayer p_140330_) {
         return p_140330_.isSpectator() && !this.level.getGameRules().getBoolean(GameRules.RULE_SPECTATORSGENERATECHUNKS);
@@ -1136,9 +_,10 @@
     }
 
     protected void addEntity(Entity p_140200_) {
-        if (!(p_140200_ instanceof EnderDragonPart)) {
+        if (!(p_140200_ instanceof net.minecraftforge.entity.PartEntity)) {
             EntityType<?> entitytype = p_140200_.getType();
             int i = entitytype.clientTrackingRange() * 16;
+         	i = org.spigotmc.TrackingRange.getEntityTrackingRange(p_140200_, i); // Spigot
             if (i != 0) {
                 int j = entitytype.updateInterval();
                 if (this.entityMap.containsKey(p_140200_.getId())) {
@@ -1297,7 +_,7 @@
         public final Set<ServerPlayerConnection> seenBy = Sets.newIdentityHashSet();
 
         public TrackedEntity(final Entity p_140478_, final int p_140479_, final int p_140480_, final boolean p_140481_) {
-            this.serverEntity = new ServerEntity(ChunkMap.this.level, p_140478_, p_140480_, p_140481_, this::broadcast);
+            this.serverEntity = new ServerEntity(ChunkMap.this.level, p_140478_, p_140480_, p_140481_, this::broadcast, this.seenBy); // CraftBukkit
             this.entity = p_140478_;
             this.range = p_140479_;
             this.lastSectionPos = SectionPos.of(p_140478_);
@@ -1348,6 +_,12 @@
                 boolean flag = d1 <= d2
                     && this.entity.broadcastToPlayer(p_140498_)
                     && ChunkMap.this.isChunkTracked(p_140498_, this.entity.chunkPosition().x, this.entity.chunkPosition().z);
+
+            	// CraftBukkit start - respect vanish API
+            	if (!p_140498_.getBukkitEntity().canSee(this.entity.getBukkitEntity())) {
+               		flag = false;
+            	}
+            	// CraftBukkit end
                 if (flag) {
                     if (this.seenBy.add(p_140498_.connection)) {
                         this.serverEntity.addPairing(p_140498_);

--- a/net/minecraft/world/item/crafting/RecipeManager.java
+++ b/net/minecraft/world/item/crafting/RecipeManager.java
@@ -1,191 +_,275 @@
 package net.minecraft.world.item.crafting;
 
-import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableMultimap;
-import com.google.common.collect.Multimap;
-import com.google.common.collect.ImmutableMultimap.Builder;
+import com.google.common.collect.Maps;
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
 import com.google.gson.JsonElement;
 import com.google.gson.JsonObject;
 import com.google.gson.JsonParseException;
+import com.google.gson.JsonSyntaxException;
+import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import com.mojang.serialization.Codec;
 import com.mojang.serialization.JsonOps;
+import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Comparator;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
-import java.util.Map.Entry;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
-import net.minecraft.core.HolderLookup;
+import net.minecraft.Util;
 import net.minecraft.core.NonNullList;
-import net.minecraft.resources.RegistryOps;
+import net.minecraft.core.registries.BuiltInRegistries;
 import net.minecraft.resources.ResourceLocation;
 import net.minecraft.server.packs.resources.ResourceManager;
 import net.minecraft.server.packs.resources.SimpleJsonResourceReloadListener;
+import net.minecraft.util.GsonHelper;
 import net.minecraft.util.profiling.ProfilerFiller;
 import net.minecraft.world.Container;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.level.Level;
+import net.minecraftforge.registries.ForgeRegistries;
 import org.slf4j.Logger;
 
 public class RecipeManager extends SimpleJsonResourceReloadListener {
-    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().disableHtmlEscaping().create();
-    private static final Logger LOGGER = LogUtils.getLogger();
-    private final HolderLookup.Provider registries;
-    private Multimap<RecipeType<?>, RecipeHolder<?>> byType = ImmutableMultimap.of();
-    private Map<ResourceLocation, RecipeHolder<?>> byName = ImmutableMap.of();
-    private boolean hasErrors;
-
-    public RecipeManager(HolderLookup.Provider p_330459_) {
-        super(GSON, "recipes");
-        this.registries = p_330459_;
-    }
-
-    protected void apply(Map<ResourceLocation, JsonElement> p_44037_, ResourceManager p_44038_, ProfilerFiller p_44039_) {
-        this.hasErrors = false;
-        Builder<RecipeType<?>, RecipeHolder<?>> builder = ImmutableMultimap.builder();
-        com.google.common.collect.ImmutableMap.Builder<ResourceLocation, RecipeHolder<?>> builder1 = ImmutableMap.builder();
-        RegistryOps<JsonElement> registryops = this.registries.createSerializationContext(JsonOps.INSTANCE);
-
-        for (Entry<ResourceLocation, JsonElement> entry : p_44037_.entrySet()) {
-            ResourceLocation resourcelocation = entry.getKey();
-
-            try {
-                Recipe<?> recipe = Recipe.CODEC.parse(registryops, entry.getValue()).getOrThrow(JsonParseException::new);
-                RecipeHolder<?> recipeholder = new RecipeHolder<>(resourcelocation, recipe);
-                builder.put(recipe.getType(), recipeholder);
-                builder1.put(resourcelocation, recipeholder);
-            } catch (IllegalArgumentException | JsonParseException jsonparseexception) {
-                LOGGER.error("Parsing error loading recipe {}", resourcelocation, jsonparseexception);
-            }
-        }
-
-        this.byType = builder.build();
-        this.byName = builder1.build();
-        LOGGER.info("Loaded {} recipes", this.byType.size());
-    }
-
-    public boolean hadErrorsLoading() {
-        return this.hasErrors;
-    }
-
-    public <C extends Container, T extends Recipe<C>> Optional<RecipeHolder<T>> getRecipeFor(RecipeType<T> p_44016_, C p_44017_, Level p_44018_) {
-        return this.byType(p_44016_).stream().filter(p_296918_ -> p_296918_.value().matches(p_44017_, p_44018_)).findFirst();
-    }
-
-    public <C extends Container, T extends Recipe<C>> Optional<RecipeHolder<T>> getRecipeFor(
-        RecipeType<T> p_220249_, C p_220250_, Level p_220251_, @Nullable ResourceLocation p_220252_
-    ) {
-        if (p_220252_ != null) {
-            RecipeHolder<T> recipeholder = this.byKeyTyped(p_220249_, p_220252_);
-            if (recipeholder != null && recipeholder.value().matches(p_220250_, p_220251_)) {
-                return Optional.of(recipeholder);
-            }
-        }
-
-        return this.byType(p_220249_).stream().filter(p_296912_ -> p_296912_.value().matches(p_220250_, p_220251_)).findFirst();
-    }
-
-    public <C extends Container, T extends Recipe<C>> List<RecipeHolder<T>> getAllRecipesFor(RecipeType<T> p_44014_) {
-        return List.copyOf(this.byType(p_44014_));
-    }
-
-    public <C extends Container, T extends Recipe<C>> List<RecipeHolder<T>> getRecipesFor(RecipeType<T> p_44057_, C p_44058_, Level p_44059_) {
-        return this.byType(p_44057_)
-            .stream()
-            .filter(p_327199_ -> p_327199_.value().matches(p_44058_, p_44059_))
-            .sorted(Comparator.comparing(p_327196_ -> p_327196_.value().getResultItem(p_44059_.registryAccess()).getDescriptionId()))
-            .collect(Collectors.toList());
-    }
-
-    private <C extends Container, T extends Recipe<C>> Collection<RecipeHolder<T>> byType(RecipeType<T> p_44055_) {
-        return (Collection)this.byType.get(p_44055_);
-    }
-
-    public <C extends Container, T extends Recipe<C>> NonNullList<ItemStack> getRemainingItemsFor(RecipeType<T> p_44070_, C p_44071_, Level p_44072_) {
-        Optional<RecipeHolder<T>> optional = this.getRecipeFor(p_44070_, p_44071_, p_44072_);
-        if (optional.isPresent()) {
-            return optional.get().value().getRemainingItems(p_44071_);
-        } else {
-            NonNullList<ItemStack> nonnulllist = NonNullList.withSize(p_44071_.getContainerSize(), ItemStack.EMPTY);
-
-            for (int i = 0; i < nonnulllist.size(); i++) {
-                nonnulllist.set(i, p_44071_.getItem(i));
-            }
-
-            return nonnulllist;
-        }
-    }
-
-    public Optional<RecipeHolder<?>> byKey(ResourceLocation p_44044_) {
-        return Optional.ofNullable(this.byName.get(p_44044_));
-    }
-
-    @Nullable
-    private <T extends Recipe<?>> RecipeHolder<T> byKeyTyped(RecipeType<T> p_332930_, ResourceLocation p_335282_) {
-        RecipeHolder<?> recipeholder = this.byName.get(p_335282_);
-        return (RecipeHolder<T>)(recipeholder != null && recipeholder.value().getType().equals(p_332930_) ? recipeholder : null);
-    }
-
-    public Collection<RecipeHolder<?>> getOrderedRecipes() {
-        return this.byType.values();
-    }
-
-    public Collection<RecipeHolder<?>> getRecipes() {
-        return this.byName.values();
-    }
-
-    public Stream<ResourceLocation> getRecipeIds() {
-        return this.byName.keySet().stream();
-    }
-
-    @VisibleForTesting
-    protected static RecipeHolder<?> fromJson(ResourceLocation p_44046_, JsonObject p_44047_, HolderLookup.Provider p_328308_) {
-        Recipe<?> recipe = Recipe.CODEC.parse(p_328308_.createSerializationContext(JsonOps.INSTANCE), p_44047_).getOrThrow(JsonParseException::new);
-        return new RecipeHolder<>(p_44046_, recipe);
-    }
-
-    public void replaceRecipes(Iterable<RecipeHolder<?>> p_44025_) {
-        this.hasErrors = false;
-        Builder<RecipeType<?>, RecipeHolder<?>> builder = ImmutableMultimap.builder();
-        com.google.common.collect.ImmutableMap.Builder<ResourceLocation, RecipeHolder<?>> builder1 = ImmutableMap.builder();
-
-        for (RecipeHolder<?> recipeholder : p_44025_) {
-            RecipeType<?> recipetype = recipeholder.value().getType();
-            builder.put(recipetype, recipeholder);
-            builder1.put(recipeholder.id(), recipeholder);
-        }
-
-        this.byType = builder.build();
-        this.byName = builder1.build();
-    }
-
-    public static <C extends Container, T extends Recipe<C>> RecipeManager.CachedCheck<C, T> createCheck(final RecipeType<T> p_220268_) {
-        return new RecipeManager.CachedCheck<C, T>() {
-            @Nullable
-            private ResourceLocation lastRecipe;
-
-            @Override
-            public Optional<RecipeHolder<T>> getRecipeFor(C p_220278_, Level p_220279_) {
-                RecipeManager recipemanager = p_220279_.getRecipeManager();
-                Optional<RecipeHolder<T>> optional = recipemanager.getRecipeFor(p_220268_, p_220278_, p_220279_, this.lastRecipe);
-                if (optional.isPresent()) {
-                    RecipeHolder<T> recipeholder = optional.get();
-                    this.lastRecipe = recipeholder.id();
-                    return Optional.of(recipeholder);
-                } else {
-                    return Optional.empty();
-                }
-            }
-        };
-    }
-
-    public interface CachedCheck<C extends Container, T extends Recipe<C>> {
-        Optional<RecipeHolder<T>> getRecipeFor(C p_220280_, Level p_220281_);
-    }
+   private static final Gson GSON = (new GsonBuilder()).setPrettyPrinting().disableHtmlEscaping().create();
+   private static final Logger LOGGER = LogUtils.getLogger();
+   public Map<RecipeType<?>, Map<ResourceLocation, RecipeHolder<?>>> recipes = ImmutableMap.of();
+   private Map<ResourceLocation, RecipeHolder<?>> byName = ImmutableMap.of();
+   private boolean hasErrors;
+   private final net.minecraftforge.common.crafting.conditions.ICondition.IContext context; //Forge: add context
+   public Map<RecipeType<?>, Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>>> recipesCB = ImmutableMap.of(); // CraftBukkit  // Mohist use obf name
+
+   /** @deprecated Forge: use {@linkplain RecipeManager#RecipeManager(net.minecraftforge.common.crafting.conditions.ICondition.IContext) constructor with context}. */
+   @Deprecated
+   public RecipeManager() {
+      this(net.minecraftforge.common.crafting.conditions.ICondition.IContext.EMPTY);
+   }
+
+   public RecipeManager(net.minecraftforge.common.crafting.conditions.ICondition.IContext context) {
+      super(GSON, "recipes");
+      this.context = context;
+   }
+
+   protected void apply(Map<ResourceLocation, JsonElement> p_44037_, ResourceManager p_44038_, ProfilerFiller p_44039_) {
+      this.hasErrors = false;
+
+      // CraftBukkit start - SPIGOT-5667 make sure all types are populated and mutable
+      Map<RecipeType<?>, Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>>> map1 = Maps.newHashMap();
+      for (RecipeType<?> recipeType : BuiltInRegistries.RECIPE_TYPE) {
+         map1.put(recipeType, new Object2ObjectLinkedOpenHashMap<>());
+      }
+      // CraftBukkit end
+      ImmutableMap.Builder<ResourceLocation, RecipeHolder<?>> builder = ImmutableMap.builder();
+
+      for(Map.Entry<ResourceLocation, JsonElement> entry : p_44037_.entrySet()) {
+         ResourceLocation resourcelocation = entry.getKey();
+         if (resourcelocation.getPath().startsWith("_")) continue; //Forge: filter anything beginning with "_" as it's used for metadata.
+
+         try {
+            if (entry.getValue().isJsonObject() && !net.minecraftforge.common.ForgeHooks.readAndTestCondition(this.context, entry.getValue().getAsJsonObject())) {
+               LOGGER.debug("Skipping loading recipe {} as it's conditions were not met", resourcelocation);
+               continue;
+            }
+            RecipeHolder<?> recipeholder = fromJson(resourcelocation, GsonHelper.convertToJsonObject(entry.getValue(), "top element"));
+
+            // CraftBukkit start
+            map1.computeIfAbsent(recipeholder.value().getType(), (recipes) -> {
+               return new Object2ObjectLinkedOpenHashMap<>();
+               // CraftBukkit end
+            }).putAndMoveToFirst(resourcelocation, recipeholder);
+
+            builder.put(resourcelocation, recipeholder);
+         } catch (IllegalArgumentException | JsonParseException jsonparseexception) {
+            LOGGER.debug("Parsing error loading recipe {}", resourcelocation, jsonparseexception);
+         }
+      }
+
+      this.recipes = (Map) map1;
+      this.recipesCB = map1;
+      this.byName = builder.build();
+      LOGGER.info("Loaded {} recipes", (int)map1.size());
+   }
+
+   public boolean hadErrorsLoading() {
+      return this.hasErrors;
+   }
+
+   public <C extends Container, T extends Recipe<C>> Optional<RecipeHolder<T>> getRecipeFor(RecipeType<T> p_44016_, C p_44017_, Level p_44018_) {
+      Optional<RecipeHolder<T>> optional = this.byType(p_44016_).values().stream().filter((p_296918_) -> {
+         return p_296918_.value().matches(p_44017_, p_44018_);
+      }).findFirst();
+      p_44017_.setCurrentRecipe(optional.orElse(null));
+      return optional;
+   }
+
+   public <C extends Container, T extends Recipe<C>> Optional<Pair<ResourceLocation, RecipeHolder<T>>> getRecipeFor(RecipeType<T> p_220249_, C p_220250_, Level p_220251_, @Nullable ResourceLocation p_220252_) {
+      Map<ResourceLocation, RecipeHolder<T>> map = this.byType(p_220249_);
+      if (p_220252_ != null) {
+         RecipeHolder<T> recipeholder = map.get(p_220252_);
+         if (recipeholder != null && recipeholder.value().matches(p_220250_, p_220251_)) {
+            return Optional.of(Pair.of(p_220252_, recipeholder));
+         }
+      }
+
+      return map.entrySet().stream().filter((p_296906_) -> {
+         return p_296906_.getValue().value().matches(p_220250_, p_220251_);
+      }).findFirst().map((p_296909_) -> {
+         return Pair.of(p_296909_.getKey(), p_296909_.getValue());
+      });
+   }
+
+   public <C extends Container, T extends Recipe<C>> List<RecipeHolder<T>> getAllRecipesFor(RecipeType<T> p_44014_) {
+      return List.copyOf(this.byType(p_44014_).values());
+   }
+
+   public <C extends Container, T extends Recipe<C>> List<RecipeHolder<T>> getRecipesFor(RecipeType<T> p_44057_, C p_44058_, Level p_44059_) {
+      return this.byType(p_44057_).values().stream().filter((p_296912_) -> {
+         return p_296912_.value().matches(p_44058_, p_44059_);
+      }).sorted(Comparator.comparing((p_296908_) -> {
+         return p_296908_.value().getResultItem(p_44059_.registryAccess()).getDescriptionId();
+      })).collect(Collectors.toList());
+   }
+
+   private <C extends Container, T extends Recipe<C>> Map<ResourceLocation, RecipeHolder<T>> byType(RecipeType<T> p_44055_) {
+      return (Map<ResourceLocation, RecipeHolder<T>>)(Map)this.recipes.getOrDefault(p_44055_, Collections.emptyMap());
+   }
+
+   public <C extends Container, T extends Recipe<C>> NonNullList<ItemStack> getRemainingItemsFor(RecipeType<T> p_44070_, C p_44071_, Level p_44072_) {
+      Optional<RecipeHolder<T>> optional = this.getRecipeFor(p_44070_, p_44071_, p_44072_);
+      if (optional.isPresent()) {
+         return optional.get().value().getRemainingItems(p_44071_);
+      } else {
+         NonNullList<ItemStack> nonnulllist = NonNullList.withSize(p_44071_.getContainerSize(), ItemStack.EMPTY);
+
+         for(int i = 0; i < nonnulllist.size(); ++i) {
+            nonnulllist.set(i, p_44071_.getItem(i));
+         }
+
+         return nonnulllist;
+      }
+   }
+
+   public Optional<RecipeHolder<?>> byKey(ResourceLocation p_44044_) {
+      return Optional.ofNullable(this.byName.get(p_44044_));
+   }
+
+   public Collection<RecipeHolder<?>> getRecipes() {
+      return this.recipes.values().stream().flatMap((p_220270_) -> {
+         return p_220270_.values().stream();
+      }).collect(Collectors.toSet());
+   }
+
+   public Stream<ResourceLocation> getRecipeIds() {
+      return this.recipes.values().stream().flatMap((p_220258_) -> {
+         return p_220258_.keySet().stream();
+      });
+   }
+
+   protected static RecipeHolder<?> fromJson(ResourceLocation p_44046_, JsonObject p_44047_) {
+      Recipe<?> recipe = Util.getOrThrow(Recipe.CODEC.parse(JsonOps.INSTANCE, p_44047_), JsonParseException::new);
+      return new RecipeHolder<>(p_44046_, recipe);
+   }
+
+   public void replaceRecipes(Iterable<RecipeHolder<?>> p_44025_) {
+      this.hasErrors = false;
+      Map<RecipeType<?>, Map<ResourceLocation, RecipeHolder<?>>> map = Maps.newHashMap();
+      ImmutableMap.Builder<ResourceLocation, RecipeHolder<?>> builder = ImmutableMap.builder();
+      p_44025_.forEach((p_296915_) -> {
+         Map<ResourceLocation, RecipeHolder<?>> map1 = map.computeIfAbsent(p_296915_.value().getType(), (p_220272_) -> {
+            return Maps.newHashMap();
+         });
+         ResourceLocation resourcelocation = p_296915_.id();
+         RecipeHolder<?> recipeholder = map1.put(resourcelocation, p_296915_);
+         builder.put(resourcelocation, p_296915_);
+         if (recipeholder != null) {
+            throw new IllegalStateException("Duplicate recipe ignored with ID " + resourcelocation);
+         }
+      });
+      this.recipes = ImmutableMap.copyOf(map);
+      this.byName = builder.build();
+   }
+
+   public static <C extends Container, T extends Recipe<C>> RecipeManager.CachedCheck<C, T> createCheck(final RecipeType<T> p_220268_) {
+      return new RecipeManager.CachedCheck<C, T>() {
+         @Nullable
+         private ResourceLocation lastRecipe;
+
+         public Optional<RecipeHolder<T>> getRecipeFor(C p_220278_, Level p_220279_) {
+            RecipeManager recipemanager = p_220279_.getRecipeManager();
+            Optional<Pair<ResourceLocation, RecipeHolder<T>>> optional = recipemanager.getRecipeFor(p_220268_, p_220278_, p_220279_, this.lastRecipe);
+            if (optional.isPresent()) {
+               Pair<ResourceLocation, RecipeHolder<T>> pair = optional.get();
+               this.lastRecipe = pair.getFirst();
+               return Optional.of(pair.getSecond());
+            } else {
+               return Optional.empty();
+            }
+         }
+      };
+   }
+
+   public interface CachedCheck<C extends Container, T extends Recipe<C>> {
+      Optional<RecipeHolder<T>> getRecipeFor(C p_220280_, Level p_220281_);
+   }
+
+   // CraftBukkit start
+   public void addRecipe(RecipeHolder<?> irecipe) {
+      Map<ResourceLocation, RecipeHolder<?>> map = this.recipes.get(irecipe.value().getType());
+      Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>> map0;
+      if (!(map instanceof Object2ObjectLinkedOpenHashMap)) {
+         Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>> hashMap = new Object2ObjectLinkedOpenHashMap<>();
+         hashMap.putAll(map);
+         if (this.recipes instanceof ImmutableMap) {
+            this.recipes = new HashMap<>(recipes);
+         }
+         this.recipes.put(irecipe.value().getType(), hashMap);
+         map0 = hashMap;
+      } else {
+         map0 = ((Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>>) map);
+      }
+
+      Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>> craftbukkit = this.recipesCB.get(irecipe.value().getType()); // CraftBukkit
+
+      if (this.byName.containsKey(irecipe.id()) || map0.containsKey(irecipe.id()) || craftbukkit.containsKey(irecipe.id())) {
+         throw new IllegalStateException("Duplicate recipe ignored with ID " + irecipe.id());
+      } else {
+         if (this.byName instanceof ImmutableMap) {
+            this.byName = new HashMap<>(byName);
+         }
+         map0.putAndMoveToFirst(irecipe.id(), irecipe);
+         craftbukkit.putAndMoveToFirst(irecipe.id(), irecipe); // CraftBukkit - SPIGOT-4638: last recipe gets priority
+         this.byName.put(irecipe.id(), irecipe);
+      }
+   }
+
+   public void clearRecipes() {
+      this.recipes = Maps.newHashMap();
+      for (RecipeType<?> recipeType : ForgeRegistries.RECIPE_TYPES) {
+         this.recipes.put(recipeType, ImmutableMap.of());
+      }
+
+      this.recipesCB = Maps.newHashMap();
+      for (RecipeType<?> recipeType : BuiltInRegistries.RECIPE_TYPE) {
+         this.recipesCB.put(recipeType, new Object2ObjectLinkedOpenHashMap<>());
+      }
+      this.byName = new HashMap<>();
+   }
+
+   public boolean removeRecipe(ResourceLocation mcKey) {
+      for (Map<ResourceLocation, RecipeHolder<?>> recipes : recipes.values()) {
+         recipes.remove(mcKey);
+      }
+      for (Object2ObjectLinkedOpenHashMap<ResourceLocation, RecipeHolder<?>> recipes0 : recipesCB.values()) {
+         recipes0.remove(mcKey);
+      }
+      return byName.remove(mcKey) != null;
+   }
+   // CraftBukkit end
 }

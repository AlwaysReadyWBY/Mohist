--- a/net/minecraft/world/entity/Mob.java
+++ b/net/minecraft/world/entity/Mob.java
@@ -85,6 +_,16 @@
 import net.minecraft.world.level.storage.loot.parameters.LootContextParamSets;
 import net.minecraft.world.level.storage.loot.parameters.LootContextParams;
 import net.minecraft.world.phys.AABB;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.event.entity.EntityCombustByEntityEvent;
+import org.bukkit.event.entity.EntityRemoveEvent;
+import org.bukkit.event.entity.EntityRemoveEvent.Cause;
+import org.bukkit.event.entity.EntityTargetEvent;
+import org.bukkit.event.entity.EntityTransformEvent;
+import org.bukkit.event.entity.EntityUnleashEvent;
+import org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;
+import org.jetbrains.annotations.VisibleForTesting;
 
 public abstract class Mob extends LivingEntity implements EquipmentUser, Targeting {
     private static final EntityDataAccessor<Byte> DATA_MOB_FLAGS_ID = SynchedEntityData.defineId(Mob.class, EntityDataSerializers.BYTE);
@@ -115,17 +_,17 @@
     private LivingEntity target;
     private final Sensing sensing;
     private final NonNullList<ItemStack> handItems = NonNullList.withSize(2, ItemStack.EMPTY);
-    public final float[] handDropChances = new float[2];
+    protected final float[] handDropChances = new float[2];
     private final NonNullList<ItemStack> armorItems = NonNullList.withSize(4, ItemStack.EMPTY);
-    public final float[] armorDropChances = new float[4];
+    protected final float[] armorDropChances = new float[4];
     private ItemStack bodyArmorItem = ItemStack.EMPTY;
     protected float bodyArmorDropChance;
     private boolean canPickUpLoot;
-    public boolean persistenceRequired;
+    private boolean persistenceRequired;
     private final Map<PathType, Float> pathfindingMalus = Maps.newEnumMap(PathType.class);
     @Nullable
-    public ResourceKey<LootTable> lootTable;
-    public long lootTableSeed;
+    private ResourceKey<LootTable> lootTable;
+    private long lootTableSeed;
     @Nullable
     private Entity leashHolder;
     private int delayedLeashHolderId;
@@ -133,6 +_,10 @@
     private Either<UUID, BlockPos> delayedLeashInfo;
     private BlockPos restrictCenter = BlockPos.ZERO;
     private float restrictRadius = -1.0F;
+    @Nullable
+    private MobSpawnType spawnType;
+    private boolean spawnCancelled = false;
+   	public boolean aware = true; // CraftBukkit
 
     protected Mob(EntityType<? extends Mob> p_21368_, Level p_21369_) {
         super(p_21368_, p_21369_);
@@ -233,14 +_,28 @@
         return this.target;
     }
 
-    @Nullable
-    protected final LivingEntity getTargetFromBrain() {
-        return this.getBrain().getMemory(MemoryModuleType.ATTACK_TARGET).orElse(null);
-    }
+   public void setTarget(@Nullable LivingEntity p_21544_) {
+      if (getTarget() == p_21544_) return;
+      net.minecraftforge.event.entity.living.LivingChangeTargetEvent changeTargetEvent = net.minecraftforge.common.ForgeHooks.onLivingChangeTarget(this, p_21544_, net.minecraftforge.event.entity.living.LivingChangeTargetEvent.LivingTargetType.MOB_TARGET);
+      if(!changeTargetEvent.isCanceled()) {
+         this.target = changeTargetEvent.getNewTarget();
+      }
+   }
 
-    public void setTarget(@Nullable LivingEntity p_21544_) {
-        this.target = p_21544_;
-    }
+   // Mohist start
+   public boolean setTarget(@Nullable LivingEntity pTarget, EntityTargetEvent.TargetReason reason, boolean fireEvent) {
+      if (getTarget() == pTarget) return false;
+      net.minecraftforge.event.entity.living.LivingChangeTargetEvent changeTargetEvent = net.minecraftforge.common.ForgeHooks.onLivingChangeTarget(this, pTarget, net.minecraftforge.event.entity.living.LivingChangeTargetEvent.LivingTargetType.MOB_TARGET);
+      changeTargetEvent.setReason(reason);
+      changeTargetEvent.setfireCBEvent(fireEvent);
+      if (!changeTargetEvent.isCanceled()) {
+         this.target = changeTargetEvent.getNewTarget();
+      } else {
+         return false;
+      }
+      return true;
+   }
+   // Mohist end
 
     @Override
     public boolean canAttackType(EntityType<?> p_21399_) {
@@ -372,6 +_,11 @@
         return null;
     }
 
+   // CraftBukkit start - Add delegate method
+   public SoundEvent getAmbientSound0() {
+      return getAmbientSound();
+   }
+   // CraftBukkit end
     @Override
     public void addAdditionalSaveData(CompoundTag p_21484_) {
         super.addAdditionalSaveData(p_21484_);
@@ -444,7 +_,13 @@
         if (this.isNoAi()) {
             p_21484_.putBoolean("NoAI", this.isNoAi());
         }
-    }
+
+        if (this.spawnType != null) {
+            p_21484_.putString("forge:spawn_type", this.spawnType.name());
+        }
+
+      	p_21484_.putBoolean("Bukkit.Aware", this.aware); // CraftBukkit
+   }
 
     @Override
     public void readAdditionalSaveData(CompoundTag p_21450_) {
@@ -510,6 +_,18 @@
         }
 
         this.setNoAi(p_21450_.getBoolean("NoAI"));
+
+        if (p_21450_.contains("forge:spawn_type")) {
+            try {
+                this.spawnType = MobSpawnType.valueOf(p_21450_.getString("forge:spawn_type"));
+            } catch (Exception ex) {
+                p_21450_.remove("forge:spawn_type");
+            }
+        }
+
+      // CraftBukkit start
+      if (p_21450_.contains("Bukkit.Aware")) {
+         this.aware = p_21450_.getBoolean("Bukkit.Aware");
     }
 
     @Override
@@ -561,7 +_,7 @@
     public void aiStep() {
         super.aiStep();
         this.level().getProfiler().push("looting");
-        if (!this.level().isClientSide && this.canPickUpLoot() && this.isAlive() && !this.dead && this.level().getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) {
+        if (!this.level().isClientSide && this.canPickUpLoot() && this.isAlive() && !this.dead && net.minecraftforge.event.ForgeEventFactory.getMobGriefingEvent(this.level(), this)) {
             Vec3i vec3i = this.getPickupReach();
 
             for (ItemEntity itementity : this.level()
@@ -581,45 +_,63 @@
 
     protected void pickUpItem(ItemEntity p_21471_) {
         ItemStack itemstack = p_21471_.getItem();
+      	this.entityitem = p_21471_;
         ItemStack itemstack1 = this.equipItemIfPossible(itemstack.copy());
         if (!itemstack1.isEmpty()) {
             this.onItemPickup(p_21471_);
             this.take(p_21471_, itemstack1.getCount());
             itemstack.shrink(itemstack1.getCount());
             if (itemstack.isEmpty()) {
-                p_21471_.discard();
-            }
-        }
-    }
-
-    public ItemStack equipItemIfPossible(ItemStack p_255842_) {
-        EquipmentSlot equipmentslot = getEquipmentSlotForItem(p_255842_);
-        ItemStack itemstack = this.getItemBySlot(equipmentslot);
-        boolean flag = this.canReplaceCurrentItem(p_255842_, itemstack);
-        if (equipmentslot.isArmor() && !flag) {
-            equipmentslot = EquipmentSlot.MAINHAND;
-            itemstack = this.getItemBySlot(equipmentslot);
-            flag = itemstack.isEmpty();
-        }
-
-        if (flag && this.canHoldItem(p_255842_)) {
-            double d0 = (double)this.getEquipmentDropChance(equipmentslot);
-            if (!itemstack.isEmpty() && (double)Math.max(this.random.nextFloat() - 0.1F, 0.0F) < d0) {
-                this.spawnAtLocation(itemstack);
-            }
-
-            if (equipmentslot.isArmor() && p_255842_.getCount() > 1) {
-                ItemStack itemstack1 = p_255842_.copyWithCount(1);
-                this.setItemSlotAndDropWhenKilled(equipmentslot, itemstack1);
-                return itemstack1;
-            } else {
-                this.setItemSlotAndDropWhenKilled(equipmentslot, p_255842_);
-                return p_255842_;
-            }
-        } else {
-            return ItemStack.EMPTY;
-        }
-    }
+            p_21471_.putRemoveCause(Cause.PICKUP); // CraftBukkit - add Bukkit remove cause
+            p_21471_.discard();
+         }
+      }
+
+   }
+
+
+   public ItemEntity entityitem = null;
+   public ItemStack equipItemIfPossible(ItemStack p_255842_) {
+      EquipmentSlot equipmentslot = getEquipmentSlotForItem(p_255842_);
+      ItemStack itemstack = this.getItemBySlot(equipmentslot);
+      boolean flag = this.canReplaceCurrentItem(p_255842_, itemstack);
+      if (equipmentslot.isArmor() && !flag) {
+         equipmentslot = EquipmentSlot.MAINHAND;
+         itemstack = this.getItemBySlot(equipmentslot);
+         flag = this.canReplaceCurrentItem(p_255842_, itemstack);
+      }
+
+      // CraftBukkit start
+      boolean canPickup = flag && this.canHoldItem(itemstack);
+      if (entityitem != null) {
+         canPickup = !CraftEventFactory.callEntityPickupItemEvent(this, entityitem, 0, !canPickup).isCancelled();
+      }
+      if (canPickup) {
+         // CraftBukkit end
+         double d0 = (double)this.getEquipmentDropChance(equipmentslot);
+         if (!itemstack.isEmpty() && (double)Math.max(this.random.nextFloat() - 0.1F, 0.0F) < d0) {
+            this.forceDrops = true; // CraftBukkit
+            this.spawnAtLocation(itemstack);
+            this.forceDrops = false; // CraftBukkit
+         }
+
+         if (equipmentslot.isArmor() && p_255842_.getCount() > 1) {
+            ItemStack itemstack1 = p_255842_.copyWithCount(1);
+            this.setItemSlotAndDropWhenKilled(equipmentslot, itemstack1);
+            return itemstack1;
+         } else {
+            this.setItemSlotAndDropWhenKilled(equipmentslot, p_255842_);
+            return p_255842_;
+         }
+      } else {
+         return ItemStack.EMPTY;
+      }
+   }
+
+   public ItemStack equipItemIfPossible(ItemStack itemstack, ItemEntity entityitem) {
+      this.entityitem = entityitem;
+      return equipItemIfPossible(itemstack);
+   }
 
     protected void setItemSlotAndDropWhenKilled(EquipmentSlot p_21469_, ItemStack p_21470_) {
         this.setItemSlot(p_21469_, p_21470_);
@@ -730,17 +_,27 @@
             this.discard();
         } else if (!this.isPersistenceRequired() && !this.requiresCustomPersistence()) {
             Entity entity = this.level().getNearestPlayer(this, -1.0);
+            var result = net.minecraftforge.event.ForgeEventFactory.canEntityDespawn(this, (ServerLevel)this.level());
+            if (result == net.minecraftforge.eventbus.api.Event.Result.DENY) {
+                noActionTime = 0;
+                entity = null;
+            } else if (result == net.minecraftforge.eventbus.api.Event.Result.ALLOW) {
+                this.discard();
+                entity = null;
+            }
             if (entity != null) {
                 double d0 = entity.distanceToSqr(this);
                 int i = this.getType().getCategory().getDespawnDistance();
                 int j = i * i;
                 if (d0 > (double)j && this.removeWhenFarAway(d0)) {
+               	this.putRemoveCause(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
                     this.discard();
                 }
 
                 int k = this.getType().getCategory().getNoDespawnDistance();
                 int l = k * k;
                 if (this.noActionTime > 600 && this.random.nextInt(800) == 0 && d0 > (double)l && this.removeWhenFarAway(d0)) {
+               		this.putRemoveCause(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
                     this.discard();
                 } else if (d0 < (double)l) {
                     this.noActionTime = 0;
@@ -1127,6 +_,16 @@
         }
     }
 
+    /**
+     * Forge: Override-Only, call via ForgeEventFactory.onFinalizeSpawn.<br>
+     * Overrides are allowed. Do not wrap super calls within override (as that will cause stack overflows).<br>
+     * Vanilla calls are replaced with a transformer, and are not visible in source.<br>
+     * <p>
+     * Be certain to either call super.finalizeSpawn or set the {@link #spawnType} field from within your override.
+     * @see {@link net.minecraftforge.event.ForgeEventFactory#onFinalizeSpawn onFinalizeSpawn} for additional documentation.
+     */
+    @Deprecated
+    @org.jetbrains.annotations.ApiStatus.OverrideOnly
     @Nullable
     public SpawnGroupData finalizeSpawn(ServerLevelAccessor p_21434_, DifficultyInstance p_21435_, MobSpawnType p_21436_, @Nullable SpawnGroupData p_21437_) {
         RandomSource randomsource = p_21434_.getRandom();
@@ -1135,6 +_,7 @@
                 new AttributeModifier("Random spawn bonus", randomsource.triangle(0.0, 0.11485000000000001), AttributeModifier.Operation.ADD_MULTIPLIED_BASE)
             );
         this.setLeftHanded(randomsource.nextFloat() < 0.05F);
+        this.spawnType = p_21436_;
         return p_21437_;
     }
 
@@ -1142,6 +_,11 @@
         this.persistenceRequired = true;
     }
 
+   // CraftBukkit start
+   public void setPersistenceRequired(boolean persistenceRequired) {
+      this.persistenceRequired = persistenceRequired;
+   }
+   // CraftBukkit end
     @Override
     public void setDropChance(EquipmentSlot p_21410_, float p_21411_) {
         switch (p_21410_.getType()) {
@@ -1179,6 +_,12 @@
         if (!this.isAlive()) {
             return InteractionResult.PASS;
         } else if (this.getLeashHolder() == p_21420_) {
+         // CraftBukkit start - fire PlayerUnleashEntityEvent
+         if (CraftEventFactory.callPlayerUnleashEntityEvent(this, p_21420_, p_21421_).isCancelled()) {
+            ((ServerPlayer) p_21420_).connection.send(new ClientboundSetEntityLinkPacket(this, this.getLeashHolder()));
+            return InteractionResult.PASS;
+         }
+         // CraftBukkit end
             this.dropLeash(true, !p_21420_.hasInfiniteMaterials());
             this.gameEvent(GameEvent.ENTITY_INTERACT, p_21420_);
             return InteractionResult.sidedSuccess(this.level().isClientSide);
@@ -1202,6 +_,12 @@
     private InteractionResult checkAndHandleImportantInteractions(Player p_21500_, InteractionHand p_21501_) {
         ItemStack itemstack = p_21500_.getItemInHand(p_21501_);
         if (itemstack.is(Items.LEAD) && this.canBeLeashed(p_21500_)) {
+         // CraftBukkit start - fire PlayerLeashEntityEvent
+         if (CraftEventFactory.callPlayerLeashEntityEvent(this, p_21500_, p_21500_, p_21501_).isCancelled()) {
+            ((ServerPlayer) p_21500_).connection.send(new ClientboundSetEntityLinkPacket(this, this.getLeashHolder()));
+            return InteractionResult.PASS;
+         }
+         // CraftBukkit end
             this.setLeashedTo(p_21500_, true);
             itemstack.shrink(1);
             return InteractionResult.sidedSuccess(this.level().isClientSide);
@@ -1300,6 +_,10 @@
                     }
                 }
 
+            	// CraftBukkit start
+            	if (CraftEventFactory.callEntityTransformEvent(this, t, this.transformReason.getAndSet(EntityTransformEvent.TransformReason.UNKNOWN)).isCancelled()) {
+               		return null;
+            	}
                 this.level().addFreshEntity(t);
                 if (this.isPassenger()) {
                     Entity entity = this.getVehicle();
@@ -1313,6 +_,19 @@
         }
     }
 
+   // Mohist start
+   public AtomicReference<EntityTransformEvent.TransformReason> transformReason = new AtomicReference<>(EntityTransformEvent.TransformReason.UNKNOWN);
+   public void transformReasonAndspawnReason(EntityTransformEvent.TransformReason transformReason, CreatureSpawnEvent.SpawnReason spawnReason) {
+      this.transformReason.set(transformReason);
+      this.spawnReason(spawnReason);
+   }
+   @Nullable
+   public <T extends Mob> T convertTo(EntityType<T> pEntityType, boolean pTransferInventory, EntityTransformEvent.TransformReason transformReason, CreatureSpawnEvent.SpawnReason spawnReason) {
+      transformReasonAndspawnReason(transformReason, spawnReason);
+      return convertTo(pEntityType, pTransferInventory);
+   }
+   // Mohist end
+
     protected void tickLeash() {
         if (this.delayedLeashInfo != null) {
             this.restoreLeashFromSave();
@@ -1331,8 +_,10 @@
             this.delayedLeashInfo = null;
             this.clearRestriction();
             if (!this.level().isClientSide && p_21457_) {
-                this.spawnAtLocation(Items.LEAD);
-            }
+            this.forceDrops = true; // CraftBukkit
+            this.spawnAtLocation(Items.LEAD);
+            this.forceDrops = false; // CraftBukkit
+         }
 
             if (!this.level().isClientSide && p_21456_ && this.level() instanceof ServerLevel) {
                 ((ServerLevel)this.level()).getChunkSource().broadcast(this, new ClientboundSetEntityLinkPacket(this, null));
@@ -1382,6 +_,7 @@
     public boolean startRiding(Entity p_21396_, boolean p_21397_) {
         boolean flag = super.startRiding(p_21396_, p_21397_);
         if (flag && this.isLeashed()) {
+         this.level.getCraftServer().getPluginManager().callEvent(new EntityUnleashEvent(this.getBukkitEntity(), UnleashReason.UNKNOWN)); // CraftBukkit
             this.dropLeash(true, true);
         }
 
@@ -1404,8 +_,10 @@
             }
 
             if (this.tickCount > 100) {
-                this.spawnAtLocation(Items.LEAD);
-                this.delayedLeashInfo = null;
+            	this.forceDrops = true; // CraftBukkit
+            	this.spawnAtLocation(Items.LEAD);
+            	this.forceDrops = false; // CraftBukkit
+            	this.leashInfoTag = null;
             }
         }
     }
@@ -1486,8 +_,15 @@
 
         int i = EnchantmentHelper.getFireAspect(this);
         if (i > 0) {
-            p_21372_.igniteForSeconds(i * 4);
-        }
+         // CraftBukkit start - Call a combust event when somebody hits with a fire enchanted item
+         EntityCombustByEntityEvent combustEvent = new EntityCombustByEntityEvent(this.getBukkitEntity(), p_21372_.getBukkitEntity(), i * 4);
+         org.bukkit.Bukkit.getPluginManager().callEvent(combustEvent);
+
+         if (!combustEvent.isCancelled()) {
+            p_21372_.setSecondsOnFire(combustEvent.getDuration(), false);
+         }
+         // CraftBukkit end
+      }
 
         boolean flag = p_21372_.hurt(this.damageSources().mobAttack(this), f);
         if (flag) {
@@ -1521,15 +_,25 @@
         return false;
     }
 
+    @Deprecated // FORGE: use jumpInFluid instead
     @Override
     protected void jumpInLiquid(TagKey<Fluid> p_204045_) {
+        this.jumpInLiquidInternal(() -> super.jumpInLiquid(p_204045_));
+    }
+
+    private void jumpInLiquidInternal(Runnable onSuper) {
         if (this.getNavigation().canFloat()) {
-            super.jumpInLiquid(p_204045_);
+            onSuper.run();
         } else {
             this.setDeltaMovement(this.getDeltaMovement().add(0.0, 0.3, 0.0));
         }
     }
 
+    @Override
+    public void jumpInFluid(net.minecraftforge.fluids.FluidType type) {
+       this.jumpInLiquidInternal(() -> super.jumpInFluid(type));
+    }
+
     @VisibleForTesting
     public void removeFreeWill() {
         this.removeAllGoals(p_262562_ -> true);
@@ -1543,6 +_,7 @@
     @Override
     protected void removeAfterChangingDimensions() {
         super.removeAfterChangingDimensions();
+      this.level.getCraftServer().getPluginManager().callEvent(new EntityUnleashEvent(this.getBukkitEntity(), UnleashReason.UNKNOWN)); // CraftBukkit
         this.dropLeash(true, false);
         this.getAllSlots().forEach(p_278936_ -> {
             if (!p_278936_.isEmpty()) {
@@ -1556,5 +_,40 @@
     public ItemStack getPickResult() {
         SpawnEggItem spawneggitem = SpawnEggItem.byId(this.getType());
         return spawneggitem == null ? null : new ItemStack(spawneggitem);
+    }
+
+    /**
+    * Returns the type of spawn that created this mob, if applicable.
+    * If it could not be determined, this will return null.
+    * <p>
+    * This is set via {@link Mob#finalizeSpawn}, so you should not call this from within that method, instead using the parameter.
+    */
+    @Nullable
+    public final MobSpawnType getSpawnType() {
+        return this.spawnType;
+    }
+
+    /**
+     * This method exists so that spawns can be cancelled from the {@link net.minecraftforge.event.entity.living.MobSpawnEvent.FinalizeSpawn FinalizeSpawnEvent}
+     * without needing to hook up an additional handler for the {@link net.minecraftforge.event.entity.EntityJoinLevelEvent EntityJoinLevelEvent}.
+     * @return if this mob will be blocked from spawning during {@link Level#addFreshEntity(Entity)}
+     * @apiNote Not public-facing API.
+     */
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public final boolean isSpawnCancelled() {
+        return this.spawnCancelled;
+    }
+
+    /**
+     * Marks this mob as being disallowed to spawn during {@link Level#addFreshEntity(Entity)}.<p>
+     * @throws UnsupportedOperationException if this entity has already been {@link Entity#isAddedToWorld() added to the world}.
+     * @apiNote Not public-facing API.
+     */
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public final void setSpawnCancelled(boolean cancel) {
+        if (this.isAddedToWorld()) {
+            throw new UnsupportedOperationException("Late invocations of Mob#setSpawnCancelled are not permitted.");
+        }
+        this.spawnCancelled = cancel;
     }
 }

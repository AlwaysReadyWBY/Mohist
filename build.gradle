import com.mohistmc.tasks.JenkinsNumber
import net.minecraftforge.forge.tasks.*
import net.minecraftforge.forge.tasks.checks.*
import net.minecraftforge.gradle.common.tasks.ApplyBinPatches
import net.minecraftforge.gradle.common.tasks.CheckJarCompatibility
import net.minecraftforge.gradle.common.tasks.DownloadMavenArtifact
import net.minecraftforge.gradle.common.tasks.ExtractInheritance
import net.minecraftforge.gradle.patcher.tasks.GeneratePatches
import net.minecraftforge.gradle.userdev.tasks.RenameJar
import org.apache.tools.ant.filters.ReplaceTokens

import java.nio.file.Files
import java.util.stream.Collectors

import static net.minecraftforge.forge.tasks.Util.*

plugins {
    id 'com.github.ben-manes.versions' version '0.46.0'
    id 'net.minecraftforge.gradleutils' version '[2.1.3,)'
    id 'eclipse'
    id 'de.undercouch.download' version '5.4.0'
    id 'net.minecraftforge.gradle.patcher' version '[6.0.14,6.2)' apply false
    id 'net.minecraftforge.gradle.mcp' version '[6.0.14,6.2)' apply false
}

init() //Init all our extension methods!

ext {
    JAR_SIGNER = null
    MAPPING_CHANNEL = 'official'
    MC_VERSION = '1.20.2'
    MAPPING_VERSION = MC_VERSION
    MC_NEXT_VERSION = '1.21'
    MCP_VERSION = '20230921.100330'
    SNAPSHOT = false

    INSTALLER_VERSION = '2.1.+'

    GIT_INFO = gradleutils.gitInfo
    VERSION = MC_VERSION + "-" + project.forge_version
    FORGE_VERSION = project.forge_version
    MOHIST_VERSION = JenkinsNumber.info()
    ADVENTURE_VERSION = '4.14.0'

    SPECIAL_SOURCE = 'net.md-5:SpecialSource:1.11.0'
    BINPATCH_TOOL = 'net.minecraftforge:binarypatcher:1.1.1:fatjar'
    INSTALLER_TOOLS = 'net.minecraftforge:installertools:1.3.0'
    JAR_SPLITTER = 'net.minecraftforge:jarsplitter:1.1.4'
    FART = 'net.minecraftforge:ForgeAutoRenamingTool:1.0.5:all'
    
    // remove :fatjar
    BIN_PATCHER = BINPATCH_TOOL.substring(0, BINPATCH_TOOL.length() - 1 - BINPATCH_TOOL.split(':')[3].length())
}

println('Version: ' + VERSION +
        ' Java: ' + System.getProperty('java.version') +
        ' JVM: ' + System.getProperty('java.vm.version') + '(' + System.getProperty('java.vendor') + ')' +
        ' Arch: ' + System.getProperty('os.arch'))

tasks.register('downloadVersionManifest', Download) {
    src 'https://piston-meta.mojang.com/mc/game/version_manifest_v2.json'
    dest file('build/versions/version_manifest.json')
    useETag 'all'
    onlyIfModified true
    quiet true
}
tasks.register('downloadJson', Download) {
    dependsOn downloadVersionManifest
    inputs.file downloadVersionManifest.dest
    src { downloadVersionManifest.dest.json.versions.find{ it.id == MC_VERSION }.url }
    dest file("build/versions/${MC_VERSION}/version.json")
    useETag 'all'
    onlyIfModified true
    quiet true
}
tasks.register('downloadClientRaw', Download) {
    dependsOn downloadJson
    inputs.file downloadJson.dest
    src { downloadJson.dest.json.downloads.client.url }
    dest file("build/versions/${MC_VERSION}/client.jar")
    useETag 'all'
    onlyIfModified true
    quiet true
}
tasks.register('downloadServerRaw', Download) {
    dependsOn downloadJson
    inputs.file downloadJson.dest
    src { downloadJson.dest.json.downloads.server.url }
    dest file("build/versions/${MC_VERSION}/server.jar")
    useETag 'all'
    onlyIfModified true
    quiet true
}


subprojects {
    apply plugin: 'maven-publish'
    apply plugin: 'eclipse'
    apply plugin: 'java'

    group = 'net.minecraftforge'
    version = VERSION

    repositories {
        mavenLocal()
        mavenCentral()
        maven gradleutils.forgeMaven
        maven gradleutils.minecraftLibsMaven
        maven { url 'https://maven.neoforged.net/releases' }
        maven { url 'https://hub.spigotmc.org/nexus/content/groups/public/' }
        maven { url 'https://maven.mohistmc.com/' }
        maven { url 'https://maven.izzel.io/releases' }
        maven { url 'https://repo.extendedclip.com/content/repositories/placeholderapi' }
    }

    java.toolchain.languageVersion = JavaLanguageVersion.of(17)

    tasks.withType(JavaCompile).configureEach {
        options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
        options.warnings = false // Shutup deprecated for removal warnings
    }
}

project(':mcp') {
    apply plugin: 'net.minecraftforge.gradle.mcp'
    tasks.withType(AbstractPublishToMaven.class).forEach{tsk -> tsk.enabled = false } // We don't want to publish anything
    mcp {
        config MC_VERSION + '-' + MCP_VERSION
        pipeline = 'joined'
    }
}

def sharedFmlonlyForge = { Project prj ->

    def MODULE_PATH = getArtifacts(prj, prj.configurations.moduleonly, false).values().collect{"libraries/${it.downloads.artifact.path}"}.sort()
    def tokens = [
            TASK:          'forge_server',
            MAVEN_PATH:    prj.ext.MAVEN_PATH.toString(),
            FORGE_VERSION: FORGE_VERSION,
            MC_VERSION:    MC_VERSION,
            MCP_VERSION:   MCP_VERSION,
            FORGE_GROUP:   prj.group,
            IGNORE_LIST: getArtifacts(prj, prj.configurations.moduleonly, false).values().collect{it.downloads.artifact.path.rsplit('/', 1)[1]}.sort().join(','),
            MODULES: 'ALL-MODULE-PATH'
    ]

    prj.task([dependsOn: rootProject.downloadServerRaw], 'makeClasspathFiles') {
        doLast {
            def CLASS_PATH = getArtifacts(prj, prj.configurations.installer, false).values().collect{"libraries/${it.downloads.artifact.path}"} +
            [
                'libraries/' + getMavenPath(rootProject.tasks.findByPath(':fmlloader:jar')),
                "libraries/net/minecraft/server/${MC_VERSION}-${MCP_VERSION}/server-${MC_VERSION}-${MCP_VERSION}-extra.jar"
            ]
            def claimed = CLASS_PATH.collect{ it.rsplit('/', 2)[0] }.toSet() // Allow us to override versions
            try (def zip = new java.util.zip.ZipFile(rootProject.downloadServerRaw.dest)) {
                CLASS_PATH += zip.getInputStream(zip.getEntry('META-INF/classpath-joined')).text.split(';')
                    .findAll{ it.startsWith('libraries/') && !claimed.contains(it.rsplit('/', 2)[0]) }
            }

            configure(prj.installerJar) {
                from(rootProject.file('server_files/args.txt')) {
                    filter(ReplaceTokens, tokens: tokens + [MODULE_PATH: MODULE_PATH.join(';'), CLASS_PATH: CLASS_PATH.join(';')])
                    rename { 'data/win_args.txt' }
                }

                from(rootProject.file('server_files/args.txt')) {
                    filter(ReplaceTokens, tokens: tokens + [MODULE_PATH: MODULE_PATH.join(':'), CLASS_PATH: CLASS_PATH.join(':')])
                    rename { 'data/unix_args.txt' }
                }
            }
        }
    }
}

project(':mohist') {
    evaluationDependsOn(':mcp')
    apply plugin: 'java-library'
    apply plugin: 'net.minecraftforge.gradle.patcher'

    applyPatches {
        level 'WARNING'
    }


    sourceSets {
        main {
            java {
                srcDirs = [
                    "$rootDir/src/main/java",
                    "$rootDir/src/fmlcommon/java"
                ]
            }
            resources {
                srcDirs = [
                    "$rootDir/src/main/resources",
                    "$rootDir/src/generated/resources",
                    "$rootDir/src/fmlcommon/resources"
                ]
            }
        }
    }

    eclipse {
        classpath.file.whenMerged {
            // Disable optional warnings on the minecraft decompiled source code. It just muddies the warning window and hides warnings in our own codebase
            def src = entries.find { it.path == 'src/main/java' }
            src.entryAttributes['ignore_optional_problems'] = 'true'
        }

        project.resourceFilter {
            appliesTo = 'FOLDERS'
            type = 'EXCLUDE_ALL'
            matcher {
                id = 'org.eclipse.ui.ide.multiFilter'
                arguments = '1.0-name-matches-false-false-run'
            }
        }
    }

    ext {
        SPEC_VERSION = gradleutils.gitInfo.tag
        // The new versioning sceme is <MCVersion>-<ForgeMC>.<RB>.<CommitsSinceRB>
        // ForgeMC is a unique identifier for every MC version we have supported.
        // Essentially, the same as the old, except dropping the first number, and the builds are no longer unique.
        MCP_ARTIFACT = project(':mcp').mcp.config.get()
        VERSION_JSON = project(':mcp').file('build/mcp/downloadJson/version.json')
        PACKED_DEPS = [':fmlcore:jar', ':fmlloader:jar', ':javafmllanguage:jar', ':lowcodelanguage:jar', ':mclanguage:jar']
        MAVEN_PATH = "${group.replace('.', '/')}/${project.name}/${VERSION}"
    }

    configurations {
        // Don't pull all libraries, if we're missing something, add it to the installer list so the installer knows to download it.
        installer { transitive = false }
        moduleonly  { transitive = false }
        api.extendsFrom(installer)
    }

    // Mohist
    task downloadJars(type: Copy) {
        from configurations.installer
        into 'libraries'
    }

    dependencies {
        moduleonly(libs.bootstrap)
        moduleonly(libs.securemodules) // Needed by bootstrap
        moduleonly(libs.unsafe) // Needed by securemodules
        moduleonly(libs.bundles.asm) // Needed by all the black magic
        moduleonly(libs.jarjar.fs) // Filesystems need to be on the bootstrap? I think thats why this is here.
        moduleonly(libs.bundles.jimfs) // In memory file system used for ForgeDev launches

        installer(libs.unsafe)
        installer(libs.securemodules)
        installer(libs.bundles.asm) // Needed by all the black magic
        installer(libs.accesstransformers)
        installer(libs.antlr.runtime) // Dep of AccessTransformer
        installer(libs.typetools) // Dep of EventBus
        installer(libs.forgespi)
        installer(libs.coremods)
        installer(libs.nashorn) // Dep of Coremods
        installer(libs.modlauncher)
        installer(libs.mergetool.api)
        installer(libs.bundles.night.config)
        installer(libs.maven.artifact)
        installer(libs.bundles.terminalconsoleappender)
        installer(libs.mixin)
        installer(libs.bundles.jarjar)

        implementation project(':fmlcore')
        implementation project(':fmlloader')
        implementation project(':javafmllanguage')
        implementation project(':lowcodelanguage')
        implementation project(':mclanguage')
        runtimeOnly(libs.bootstrap)

        annotationProcessor 'org.spongepowered:mixin:0.8.5:processor'

        // craftbukkit
        installer 'org.fusesource.jansi:jansi:1.18'
        installer 'jline:jline:2.14.6'
        installer 'com.googlecode.json-simple:json-simple:1.1.1'
        installer 'org.xerial:sqlite-jdbc:3.43.0.0'
        installer 'com.mysql:mysql-connector-j:8.1.0'

        installer 'net.md-5:SpecialSource:1.11.2'
        // spigot
        installer 'net.md-5:bungeecord-chat:1.20-R0.1' // #14
        installer 'commons-codec:commons-codec:1.16.0'
        installer 'net.sf.jopt-simple:jopt-simple:5.0.4'

        installer 'io.izzel:tools:1.3.0'
        installer 'com.mohistmc:dynamicenum:0.2'
        installer(libs.i18n)
        installer(libs.json)
        installer(libs.tools)
        installer 'com.mohistmc:brigadier:1.20.1'
        installer 'com.mohistmc:librariesvault:1.20.2'
        installer "com.mohistmc:eventbus:6.2.0"

        compileOnly 'me.clip:placeholderapi:2.11.3'
        installer 'commons-lang:commons-lang:2.6-mohist'

        // Paper start
        installer(libs.bundles.log4j)
        installer(libs.bundles.adventure)
        // Paper end
    }

    patcher {
        excs.from file("$rootDir/src/main/resources/forge.exc")
        parent = project(':mcp')
        mcVersion = MC_VERSION
        mappings channel: MAPPING_CHANNEL, version: MAPPING_VERSION
        patches = file("$rootDir/patches/minecraft")
        patchedSrc = file('src/main/java')
        srgPatches = false
        accessTransformers.from file("$rootDir/src/main/resources/META-INF/accesstransformer.cfg")
        sideAnnotationStrippers.from file("$rootDir/src/main/resources/forge.sas")

        runs {
            forge_server {
                args '--launchTarget', 'forgeserverdev'
                ideaModule "${rootProject.name}.${project.name}.main"

                mods {
                    minecraft { source sourceSets.main }
                }
            }

            def forgeDataArgs = [
                    '--mod', 'forge',
                    '--all',
                    '--output', rootProject.file('src/generated/resources/'),
                    '--validate',
                    '--existing', sourceSets.main.resources.srcDirs[0]
            ]
            forge_data {
                taskName 'forge_data'
                args '--launchTarget', 'forgedatadev'
                ideaModule "${rootProject.name}.${project.name}.main"

                mods {
                    minecraft { source sourceSets.main }
                }

                args forgeDataArgs
            }
        }
    }

    afterEvaluate {
        if (!patcher.srgPatches) {
            srg2mcpClean {
                dependsOn = []
                input = project(':mcp').setupMCP.output
            }
            userdevJar {
                onlyIf = { t -> true }
            }
            def patches = project.file('build/genPatchesForUserdev/output/')
            patches.mkdirs()
            def genPatchesForUserdev = tasks.register('genPatchesForUserdev', GeneratePatches){
                base = project(':mcp').setupMCP.output
                modified = applyRangeMapBase.output
                originalPrefix = genPatches.originalPrefix
                modifiedPrefix = genPatches.modifiedPrefix
                output = patches
                autoHeader true
                lineEnding = '\n'
            }
            bakePatches {
                dependsOn = []
                input = genPatchesForUserdev.get().output
            }
        }
    }

    ext {
        MANIFESTS = [
                '/': [
                        'Timestamp'      : new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                        'GitCommit'      : gradleutils.gitInfo.abbreviatedId,
                        'Git-Branch'     : MC_VERSION,
                        'FML-System-Mods': 'forge',
                        'MixinConfigs': 'mohist.mixins.json'
                ] as LinkedHashMap,
                'net/minecraftforge/versions/forge/'        : [
                        'Specification-Title'   : 'Forge',
                        'Specification-Vendor'  : 'Forge Development LLC',
                        'Specification-Version' : SPEC_VERSION,
                        'Implementation-Title'  : project.group,
                        'Implementation-Version': project.version.substring(MC_VERSION.length() + 1),
                        'Implementation-Vendor' : 'Forge Development LLC'
                ] as LinkedHashMap,
                'net/minecraftforge/versions/mcp/'          : [
                        'Specification-Title'   : 'Minecraft',
                        'Specification-Vendor'  : 'Mojang',
                        'Specification-Version' : MC_VERSION,
                        'Implementation-Title'  : 'MCP',
                        'Implementation-Version': MCP_VERSION,
                        'Implementation-Vendor' : 'Forge'
                ] as LinkedHashMap,
                'net/minecraftforge/fml/javafmlmod/'        : [
                        'Specification-Title'   : 'Mod Language Provider',
                        'Specification-Vendor'  : 'Forge Development LLC',
                        'Specification-Version' : '1',
                        'Implementation-Title'  : 'FML Java Mod',
                        'Implementation-Version': SPEC_VERSION,
                        'Implementation-Vendor' : 'Forge'
                ] as LinkedHashMap,
                'net/minecraftforge/fml/mclanguageprovider/': [
                        'Specification-Title'   : 'Mod Language Provider',
                        'Specification-Vendor'  : 'Forge Development LLC',
                        'Specification-Version' : '1',
                        'Implementation-Title'  : 'Minecraft Language Mod Provider',
                        'Implementation-Version': '1',
                        'Implementation-Vendor' : 'Forge'
                ] as LinkedHashMap,
                'net/minecraftforge/fml/loading/'           : [
                        'Specification-Title'   : 'Launcher',
                        'Specification-Vendor'  : 'Forge Development LLC',
                        'Specification-Version' : '1',
                        'Implementation-Title'  : 'FML Launcher',
                        'Implementation-Version': SPEC_VERSION,
                        'Implementation-Vendor' : 'Forge'
                ] as LinkedHashMap,
                'com/mohistmc/'                             : [
                        'Specification-Title'   : 'Mohist',
                        'Specification-Vendor'  : 'MohistMC',
                        'Specification-Version' : MOHIST_VERSION,
                        'Implementation-Title'  : 'Mohist',
                        'Implementation-Version': MC_VERSION + '-' + MOHIST_VERSION,
                        'Implementation-Vendor' : 'MohistMC'
                ] as LinkedHashMap,
                'org/bukkit/craftbukkit/v1_20_R2/'          : [
                        'Specification-Title'   : MCP_VERSION,
                        'Specification-Vendor'  : 'SpigotMC',
                        'Specification-Version' : MC_VERSION,
                        'Implementation-Title'  : 'Spigot',
                        'Implementation-Version': bukkit_version + '-' +  craftbukkit_version + '-' +  spigot_version + '-' + forge_version ,
                        'Implementation-Vendor' : 'SpigotMC'
                ] as LinkedHashMap
        ]
    }

    sharedFmlonlyForge.call(project)

    task downloadLibraries(type: DownloadLibraries, dependsOn: ':mcp:setupMCP') {
        input = VERSION_JSON
        output = rootProject.file('build/libraries/')
    }

    task extractInheritance(type: ExtractInheritance, dependsOn: [downloadLibraries]) {
        tool = INSTALLER_TOOLS + ':fatjar'
        args.add '--annotations'
        input = genJoinedBinPatches.cleanJar
        libraries.addAll downloadLibraries.librariesOutput.map { rf -> Files.readAllLines(rf.asFile.toPath()).stream().map(File::new).collect(Collectors.toList()) }
    }

    tasks.register("findFieldInstanceChecks", FieldCompareFinder) {
        jar = createJoinedSRG.output
        output = rootProject.file('src/main/resources/coremods/field_to_instanceof.json')
        fields {
        }
    }

    tasks.register("findFinalizeSpawnTargets", BytecodePredicateFinder) {
        jar = createJoinedSRG.output
        output = rootProject.file('src/main/resources/coremods/finalize_spawn_targets.json')
        predicate = {
            parent, node, insn ->
                'net/minecraft/world/level/BaseSpawner' != parent.name // Ignore this class as we special case it.
                        && insn.getOpcode() == Opcodes.INVOKEVIRTUAL
                        && insn.name.equals('m_6518_')
                        && insn.desc.equals('(Lnet/minecraft/world/level/ServerLevelAccessor;Lnet/minecraft/world/DifficultyInstance;Lnet/minecraft/world/entity/MobSpawnType;Lnet/minecraft/world/entity/SpawnGroupData;Lnet/minecraft/nbt/CompoundTag;)Lnet/minecraft/world/entity/SpawnGroupData;')
        }
    }

    tasks.register('validateDeprecations', ValidateDeprecations) {
        input = tasks.jar.archiveFile
        mcVersion = MC_VERSION
    }

    tasks.jar.finalizedBy 'validateDeprecations'

    tasks.register("downloadInstaller", DownloadMavenArtifact) {
        artifact = "net.minecraftforge:installer:${INSTALLER_VERSION}:shrunk"
        changing = true
    }
    tasks.register("downloadClientSlim", DownloadMavenArtifact) {
        artifact = "net.minecraft:client:${MC_VERSION}-${MCP_VERSION}:slim"
    }
    tasks.register("downloadClientExtra", DownloadMavenArtifact) {
        artifact = "net.minecraft:client:${MC_VERSION}-${MCP_VERSION}:extra"
    }
    tasks.register("downloadServerSlim", DownloadMavenArtifact) {
        artifact = "net.minecraft:server:${MC_VERSION}-${MCP_VERSION}:slim"
    }
    tasks.register("downloadServerExtra", DownloadMavenArtifact) {
        artifact = "net.minecraft:server:${MC_VERSION}-${MCP_VERSION}:extra"
    }
    tasks.register("downloadJoinedSlim", DownloadMavenArtifact) {
        artifact = "net.minecraft:joined:${MC_VERSION}-${MCP_VERSION}:slim"
    }
    tasks.register("downloadJoinedExtra", DownloadMavenArtifact) {
        artifact = "net.minecraft:joined:${MC_VERSION}-${MCP_VERSION}:extra"
    }
    tasks.register("createJoinedSRG", DownloadMavenArtifact) {
        artifact = "net.minecraft:joined:${MC_VERSION}-${MCP_VERSION}:srg"
    }
    tasks.register("createClientSRG", RenameJar) {
        tool = FART
        args = ['--input', '{input}', '--output', '{output}', '--names', '{mappings}', '--ann-fix', '--ids-fix', '--src-fix', '--record-fix']
        mappings = createMcp2Srg.srg
        input = downloadClientSlim.output
        output = file("build/createClientSRG/output.jar")
    }
    tasks.register("createServerSRG", RenameJar) {
        tool = FART
        args = ['--input', '{input}', '--output', '{output}', '--names', '{mappings}', '--ann-fix', '--ids-fix', '--src-fix', '--record-fix']
        mappings = createMcp2Srg.srg
        input = downloadServerSlim.output
        output = file("build/createServerSRG/output.jar")
    }
    genClientBinPatches {
        tool = BINPATCH_TOOL
        cleanJar = createClientSRG.output
    }
    genServerBinPatches {
        tool = BINPATCH_TOOL
        cleanJar = createServerSRG.output
    }
    genJoinedBinPatches {
        tool = BINPATCH_TOOL
        cleanJar = createJoinedSRG.output
    }
    tasks.register("applyClientBinPatches", ApplyBinPatches) {
        tool = BINPATCH_TOOL
        clean = genClientBinPatches.cleanJar
        patch = genClientBinPatches.output
    }
    tasks.register("applyServerBinPatches", ApplyBinPatches) {
        tool = BINPATCH_TOOL
        clean = genServerBinPatches.cleanJar
        patch = genServerBinPatches.output
    }
    tasks.register("applyJoinedBinPatches", ApplyBinPatches) {
        tool = BINPATCH_TOOL
        clean = genJoinedBinPatches.cleanJar
        patch = genJoinedBinPatches.output
    }

    tasks.register('checkAll') {
        group = 'checks'
    }
    tasks.register('checkAllAndFix') {
        dependsOn 'findFinalizeSpawnTargets', 'findFieldInstanceChecks'
        group = 'checks'
    }

    CheckTask.registerTask(tasks, 'ATs', CheckATs) {
        dependsOn extractInheritance, createSrg2Mcp
        ats.from patcher.accessTransformers
        inheritance = extractInheritance.output
        mappings = createSrg2Mcp.output
    }

    CheckTask.registerTask(tasks, 'SAS', CheckSAS) {
        dependsOn extractInheritance
        sass.from patcher.sideAnnotationStrippers
        inheritance = extractInheritance.output
    }

    CheckTask.registerTask(tasks, 'Excs', CheckExcs) {
        dependsOn jar
        binary = jar.archiveFile.get().asFile
        excs.from patcher.excs
    }

    CheckTask.registerTask(tasks, 'Patches', CheckPatches) {
        dependsOn genPatches
        patchDir = file("$rootDir/patches")
        patchesWithS2SArtifact = [
                'minecraft/net/minecraft/client/renderer/ViewArea.java.patch',
                'minecraft/net/minecraft/data/models/blockstates/Variant.java.patch',
        ]
    }

    genPatches {
	    // finalizedBy checkAndFixPatches
        autoHeader true
        lineEnding = '\n'
    }

    def baseForgeVersionProperty = project.objects.property(String)
    baseForgeVersionProperty.set(project.provider { getLatestForgeVersion(MC_VERSION) }.map { MC_VERSION + '-' + it })
    baseForgeVersionProperty.finalizeValueOnRead()
    def jarCompatibilityTaskSetup = { task ->
        task.group = 'jar compatibility'
        task.onlyIf {
            baseForgeVersionProperty.getOrNull() != null
        }
    }

    tasks.register('setupCheckJarCompatibility', SetupCheckJarCompatibility) {
        inputVersion = baseForgeVersionProperty
    }

    tasks.register('applyBaseCompatibilityJarBinPatches', ApplyBinPatches) {
        jarCompatibilityTaskSetup(it)

        clean = project.tasks.createJoinedSRG.output
        patch = project.tasks.named('setupCheckJarCompatibility').flatMap { it.baseBinPatchesOutput }
        output = project.layout.buildDirectory.dir(name).map { it.file('output.jar') }
    }

    tasks.register('checkJarCompatibility', CheckJarCompatibility) {
        jarCompatibilityTaskSetup(it)
        dependsOn 'setupCheckJarCompatibility'

        baseJar = project.tasks.named('mergeBaseForgeJar').flatMap { it.output }
        baseLibraries.from(project.tasks.named('createJoinedSRG').flatMap { it.output })

        inputJar = project.tasks.named('reobfJar').flatMap { it.output }
        concreteLibraries.from(project.PACKED_DEPS.collect { project.rootProject.tasks.getByPath(it).archiveFile })

        commonLibraries.from(project.configurations.minecraftImplementation)
        commonLibraries.from(project.configurations.installer)
        commonLibraries.from(project.configurations.moduleonly)
    }

    universalJar {
        duplicatesStrategy = 'exclude'

        doFirst {
            MANIFESTS.each{ pkg, values ->
                if (pkg == '/') {
                    manifest.attributes(values)
                } else {
                    manifest.attributes(values, pkg)
                }
            }
        }
    }

    task mohistJar(type: Jar, dependsOn: [downloadServerRaw, genServerBinPatches, project(':mohistlauncher').tasks.jar]) {
        archiveClassifier = 'server'
        archiveExtension = 'jar'
        archiveBaseName = 'mohist'
        archiveVersion = MC_VERSION + '-' + MOHIST_VERSION
        destinationDirectory = file('build/libs')

        def CLASS_PATH = getArtifacts(project, project.configurations.installer, false).values().collect { "libraries/${it.downloads.artifact.path}" } +
                [
                        'libraries/' + getMavenPath(rootProject.tasks.findByPath(':fmlloader:jar')),
                        "libraries/net/minecraft/server/${MC_VERSION}-${MCP_VERSION}/server-${MC_VERSION}-${MCP_VERSION}-extra.jar",
                        "libraries/net/minecraftforge/installertools/1.3.0/installertools-1.3.0.jar"
                ]
        def claimed = CLASS_PATH.collect { it.rsplit('/', 2)[0] }.toSet() // Allow us to override versions
        if (rootProject.downloadServerRaw.dest.exists()) {
            try (def zip = new java.util.zip.ZipFile(rootProject.downloadServerRaw.dest)) {
                CLASS_PATH += zip.getInputStream(zip.getEntry('META-INF/classpath-joined')).text.split(';')
                        .findAll { it.startsWith('libraries/') && !it.contains("brigadier") && !claimed.contains(it.rsplit('/', 2)[0]) }
            }
        } else {
            println("Can't read server")
        }
        def MODULE_PATH = getArtifacts(project, project.configurations.moduleonly, false).values().collect { "libraries/${it.downloads.artifact.path}" }.sort()
        def tokens = [
                TASK         : 'forge_server',
                MAVEN_PATH   : project.ext.MAVEN_PATH.toString(),
                FORGE_VERSION: FORGE_VERSION,
                MC_VERSION   : MC_VERSION,
                MCP_VERSION  : MCP_VERSION,
                FORGE_GROUP  : project.group,
                IGNORE_LIST  : getArtifacts(project, project.configurations.moduleonly, false).values().collect { it.downloads.artifact.path.rsplit('/', 1)[1] }.sort().join(','),
                MODULES      : 'ALL-MODULE-PATH'
        ]

        doFirst {
            MANIFESTS.each { pkg, values ->
                if (pkg == '/') {
                    manifest.attributes(values += [
                            'Premain-Class': 'com.mohistmc.util.JarLoader',
                            'Launcher-Agent-Class': 'com.mohistmc.util.JarLoader',
                            'Main-Class': 'com.mohistmc.MohistMCStart'
                    ])
                } else {
                    manifest.attributes(values, pkg)
                }
            }
        }

        //println(CLASS_PATH)

        from(genServerBinPatches.output) {
            rename { 'data/server.lzma' }
        }
        from(universalJar) {
            rename { 'data/forge-' + MC_VERSION + '-' + FORGE_VERSION + '-universal.jar' }
        }
        from(project(':fmlloader').tasks.jar.outputs) {
            rename { 'data/fmlloader-' + MC_VERSION + '-' + FORGE_VERSION + '.jar' }
        }
        from(project(':fmlcore').tasks.jar.outputs) {
            rename { 'data/fmlcore-' + MC_VERSION + '-' + FORGE_VERSION + '.jar' }
        }
        from(project(':javafmllanguage').tasks.jar.outputs) {
            rename { 'data/javafmllanguage-' + MC_VERSION + '-' + FORGE_VERSION + '.jar' }
        }
        from(project(':mclanguage').tasks.jar.outputs) {
            rename { 'data/mclanguage-' + MC_VERSION + '-' + FORGE_VERSION + '.jar' }
        }
        from(project(':lowcodelanguage').tasks.jar.outputs) {
            rename { 'data/lowcodelanguage-' + MC_VERSION + '-' + FORGE_VERSION + '.jar' }
        }

        from(project(':mohistplugins').tasks.jar.outputs) {
            rename { 'data/mohistplugins-' + MC_VERSION + '.jar' }
        }

        from(zipTree(project(':mohistlauncher').tasks.jar.outputs.getFiles().asPath.replace(".jar", "-all.jar"))) {
            into ""
        }

        from(rootProject.file('server_files/version.txt')) {
            filter(ReplaceTokens, tokens: [VERSION: MOHIST_VERSION])
            rename { 'versions/mohist.txt' }
        }
        from(rootProject.file('server_files/version.txt')) {
            filter(ReplaceTokens, tokens: [VERSION: MC_VERSION])
            rename { 'versions/minecraft.txt' }
        }
        from(rootProject.file('server_files/version.txt')) {
            filter(ReplaceTokens, tokens: [VERSION: FORGE_VERSION])
            rename { 'versions/forge.txt' }
        }
        from(rootProject.file('server_files/version.txt')) {
            filter(ReplaceTokens, tokens: [VERSION: MCP_VERSION])
            rename { 'versions/mcp.txt' }
        }

        from(rootProject.file('server_files/args.txt')) {
            filter(ReplaceTokens, tokens: tokens + [MODULE_PATH: MODULE_PATH.join(';'), CLASS_PATH: CLASS_PATH.join(';')])
            rename { 'data/win_args.txt' }
        }

        from(rootProject.file('server_files/args.txt')) {
            filter(ReplaceTokens, tokens: tokens + [MODULE_PATH: MODULE_PATH.join(':'), CLASS_PATH: CLASS_PATH.join(':')])
            rename { 'data/unix_args.txt' }
        }
    }

    tasks.register('genAllData') {
        dependsOn 'forge_data'
    }

    tasks.eclipse.dependsOn('genEclipseRuns')

    // Since we need the modules in the bootstrap, we need to make sure they are compiled before we do each run
    afterEvaluate { prepareRuns.dependsOn(PACKED_DEPS) }
}

tasks.register('setup') {
    dependsOn ':clean:extractMapped'
    dependsOn ':mohist:extractMapped'
}
